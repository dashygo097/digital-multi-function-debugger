`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module uart_tx_byte_level_b115200_f100000000(
  input        clock,
               reset,
  output       UART_TX_txd,
               UART_TX_channel_ready,
  input        UART_TX_channel_valid,
  input  [7:0] UART_TX_channel_bits
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  wire       tick = tickCounter == 10'h363;
  wire       UART_TX_channel_ready_0 = state == 2'h0;
  wire       _GEN = state == 2'h1;
  wire       _GEN_0 = state == 2'h2;
  reg  [1:0] casez_tmp;
  always_comb begin
    casez (state)
      2'b00:
        casez_tmp = UART_TX_channel_valid ? 2'h1 : state;
      2'b01:
        casez_tmp = tick ? 2'h2 : state;
      2'b10:
        casez_tmp = tick & (&bitCounter) ? 2'h3 : state;
      default:
        casez_tmp = (&state) & tick ? 2'h0 : state;
    endcase
  end // always_comb
  wire       _GEN_1 = _GEN_0 & tick;
  always @(posedge clock) begin
    if (reset) begin
      state <= 2'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end
    else begin
      state <= casez_tmp;
      if (~UART_TX_channel_ready_0) begin
        if (_GEN) begin
          if (tick)
            bitCounter <= 3'h0;
        end
        else if (~_GEN_1 | (&bitCounter)) begin
        end
        else
          bitCounter <= bitCounter + 3'h1;
      end
      if (UART_TX_channel_ready_0 & UART_TX_channel_valid | tick)
        tickCounter <= 10'h0;
      else
        tickCounter <= tickCounter + 10'h1;
    end
    if (UART_TX_channel_ready_0) begin
      if (UART_TX_channel_valid)
        data <= UART_TX_channel_bits;
    end
    else if (_GEN | ~_GEN_1 | (&bitCounter)) begin
    end
    else
      data <= {1'h0, data[7:1]};
  end // always @(posedge)
  assign UART_TX_txd = UART_TX_channel_ready_0 | ~_GEN & (~_GEN_0 | data[0]);
  assign UART_TX_channel_ready = UART_TX_channel_ready_0;
endmodule

module uart_rx_byte_level_b115200_f100000000(
  input        clock,
               reset,
               UART_RX_rxd,
  output       UART_RX_channel_valid,
  output [7:0] UART_RX_channel_bits,
  output       UART_RX_error
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  wire       tick = tickCounter == 10'h363;
  reg        rxd_REG;
  reg        rxd;
  wire       _GEN = state == 2'h0;
  wire       _GEN_0 = state == 2'h1;
  wire       _GEN_1 = state == 2'h2;
  wire       _GEN_2 = _GEN | _GEN_0 | _GEN_1;
  wire       _GEN_3 = (&state) & tick;
  reg  [1:0] casez_tmp;
  always_comb begin
    casez (state)
      2'b00:
        casez_tmp = rxd ? state : 2'h1;
      2'b01:
        casez_tmp = tick ? {~rxd, 1'h0} : state;
      2'b10:
        casez_tmp = tick & (&bitCounter) ? 2'h3 : state;
      default:
        casez_tmp = _GEN_3 ? 2'h0 : state;
    endcase
  end // always_comb
  wire       _GEN_4 = _GEN_1 & tick;
  always @(posedge clock) begin
    if (reset) begin
      state <= 2'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end
    else begin
      state <= casez_tmp;
      if (~_GEN) begin
        if (_GEN_0) begin
          if (tick & ~rxd)
            bitCounter <= 3'h0;
        end
        else if (~_GEN_4 | (&bitCounter)) begin
        end
        else
          bitCounter <= bitCounter + 3'h1;
      end
      if (_GEN & ~rxd)
        tickCounter <= 10'h1B2;
      else if (tick)
        tickCounter <= 10'h0;
      else
        tickCounter <= tickCounter + 10'h1;
    end
    if (_GEN | _GEN_0 | ~_GEN_4) begin
    end
    else
      data <= {rxd, data[7:1]};
    rxd_REG <= UART_RX_rxd;
    rxd <= rxd_REG;
  end // always @(posedge)
  assign UART_RX_channel_valid = ~_GEN_2 & (&state) & tick;
  assign UART_RX_channel_bits = _GEN_2 | ~_GEN_3 ? 8'h0 : data;
  assign UART_RX_error = ~_GEN_2 & _GEN_3 & ~rxd;
endmodule

module uart_cmd_byte_level_b115200_f100000000(
  input         clock,
                reset,
  output        UART_CMD_txd,
  input         UART_CMD_rxd,
  output        UART_CMD_cmd_valid,
                UART_CMD_cmd_type,
  output [31:0] UART_CMD_cmd_addr,
                UART_CMD_cmd_wdata,
  input         UART_CMD_resp_valid,
  input  [31:0] UART_CMD_resp_rdata
);

  wire        _uart_rx_UART_RX_channel_valid;
  wire [7:0]  _uart_rx_UART_RX_channel_bits;
  wire        _uart_rx_UART_RX_error;
  wire        _uart_tx_UART_TX_channel_ready;
  reg  [1:0]  rx_state;
  reg  [3:0]  rx_byte_cnt;
  reg  [7:0]  rx_buffer_0;
  reg  [7:0]  rx_buffer_1;
  reg  [7:0]  rx_buffer_2;
  reg  [7:0]  rx_buffer_3;
  reg  [7:0]  rx_buffer_4;
  reg  [7:0]  rx_buffer_5;
  reg  [7:0]  rx_buffer_6;
  reg  [7:0]  rx_buffer_7;
  reg         cmd_valid_reg;
  reg         cmd_type_reg;
  reg  [31:0] cmd_addr_reg;
  reg  [31:0] cmd_wdata_reg;
  reg  [1:0]  tx_state;
  reg  [2:0]  tx_byte_cnt;
  reg  [7:0]  tx_buffer_1;
  reg  [7:0]  tx_buffer_2;
  reg  [7:0]  tx_buffer_3;
  reg  [7:0]  tx_buffer_4;
  reg  [3:0]  tx_total_bytes;
  wire        _GEN = tx_state == 2'h0;
  wire        _GEN_0 = tx_state == 2'h1;
  reg  [7:0]  casez_tmp;
  always_comb begin
    casez (tx_byte_cnt)
      3'b000:
        casez_tmp = 8'h0;
      3'b001:
        casez_tmp = tx_buffer_1;
      3'b010:
        casez_tmp = tx_buffer_2;
      3'b011:
        casez_tmp = tx_buffer_3;
      3'b100:
        casez_tmp = tx_buffer_4;
      3'b101:
        casez_tmp = 8'h0;
      3'b110:
        casez_tmp = 8'h0;
      default:
        casez_tmp = 8'h0;
    endcase
  end // always_comb
  wire        _GEN_1 = {1'h0, tx_byte_cnt} == tx_total_bytes - 4'h1;
  wire        _GEN_2 = rx_state == 2'h0;
  wire        _GEN_3 = _uart_rx_UART_RX_channel_valid & ~_uart_rx_UART_RX_error;
  wire        _GEN_4 = rx_state == 2'h1;
  wire [3:0]  _next_byte_cnt_T = rx_byte_cnt + 4'h1;
  wire        _GEN_5 = _next_byte_cnt_T == 4'h9;
  wire        _GEN_6 = _GEN_4 & _GEN_3 & _GEN_5;
  wire        _GEN_7 = _GEN_2 | ~_GEN_6;
  wire        _GEN_8 = _GEN & UART_CMD_resp_valid;
  always @(posedge clock) begin
    if (reset) begin
      rx_state <= 2'h0;
      rx_byte_cnt <= 4'h0;
      cmd_valid_reg <= 1'h0;
      cmd_addr_reg <= 32'h0;
      cmd_wdata_reg <= 32'h0;
      tx_state <= 2'h0;
      tx_byte_cnt <= 3'h0;
      tx_total_bytes <= 4'h0;
    end
    else begin
      if (_GEN_2) begin
        if (_GEN_3) begin
          rx_state <= 2'h1;
          rx_byte_cnt <= 4'h1;
        end
      end
      else begin
        if (_GEN_6)
          rx_state <= 2'h0;
        if (_GEN_4 & _GEN_3) begin
          if (_GEN_5)
            rx_byte_cnt <= 4'h0;
          else
            rx_byte_cnt <= _next_byte_cnt_T;
        end
      end
      cmd_valid_reg <= ~_GEN_2 & _GEN_6;
      if (_GEN_7) begin
      end
      else begin
        cmd_addr_reg <= {rx_buffer_4, rx_buffer_3, rx_buffer_2, rx_buffer_1};
        cmd_wdata_reg <=
          {_uart_rx_UART_RX_channel_bits, rx_buffer_7, rx_buffer_6, rx_buffer_5};
      end
      if (_GEN) begin
        if (UART_CMD_resp_valid) begin
          tx_state <= 2'h1;
          tx_byte_cnt <= 3'h0;
        end
      end
      else begin
        if (_GEN_0 & _uart_tx_UART_TX_channel_ready & _GEN_1)
          tx_state <= 2'h0;
        if (_GEN_0 & _uart_tx_UART_TX_channel_ready) begin
          if (_GEN_1)
            tx_byte_cnt <= 3'h0;
          else
            tx_byte_cnt <= tx_byte_cnt + 3'h1;
        end
      end
      if (_GEN_8)
        tx_total_bytes <= 4'h5;
    end
    if ((_GEN_2 | _GEN_4 & rx_byte_cnt == 4'h0) & _GEN_3)
      rx_buffer_0 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h1)) begin
    end
    else
      rx_buffer_1 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h2)) begin
    end
    else
      rx_buffer_2 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h3)) begin
    end
    else
      rx_buffer_3 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h4)) begin
    end
    else
      rx_buffer_4 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h5)) begin
    end
    else
      rx_buffer_5 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h6)) begin
    end
    else
      rx_buffer_6 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_2 | ~(_GEN_4 & _GEN_3 & rx_byte_cnt == 4'h7)) begin
    end
    else
      rx_buffer_7 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_7) begin
    end
    else
      cmd_type_reg <= |rx_buffer_0;
    if (_GEN_8) begin
      tx_buffer_1 <= UART_CMD_resp_rdata[7:0];
      tx_buffer_2 <= UART_CMD_resp_rdata[15:8];
      tx_buffer_3 <= UART_CMD_resp_rdata[23:16];
      tx_buffer_4 <= UART_CMD_resp_rdata[31:24];
    end
  end // always @(posedge)
  uart_tx_byte_level_b115200_f100000000 uart_tx (
    .clock                 (clock),
    .reset                 (reset),
    .UART_TX_txd           (UART_CMD_txd),
    .UART_TX_channel_ready (_uart_tx_UART_TX_channel_ready),
    .UART_TX_channel_valid (~_GEN & _GEN_0),
    .UART_TX_channel_bits  (_GEN | ~_GEN_0 ? 8'h0 : casez_tmp)
  );
  uart_rx_byte_level_b115200_f100000000 uart_rx (
    .clock                 (clock),
    .reset                 (reset),
    .UART_RX_rxd           (UART_CMD_rxd),
    .UART_RX_channel_valid (_uart_rx_UART_RX_channel_valid),
    .UART_RX_channel_bits  (_uart_rx_UART_RX_channel_bits),
    .UART_RX_error         (_uart_rx_UART_RX_error)
  );
  assign UART_CMD_cmd_valid = cmd_valid_reg;
  assign UART_CMD_cmd_type = cmd_type_reg;
  assign UART_CMD_cmd_addr = cmd_addr_reg;
  assign UART_CMD_cmd_wdata = cmd_wdata_reg;
endmodule

module axilite_master_uart_cmd_32x32_b115200_f100000000(
  input         clock,
                reset,
  output [31:0] M_AXI_AWADDR,
  output [2:0]  M_AXI_AWPROT,
  output        M_AXI_AWVALID,
  input         M_AXI_AWREADY,
  output [31:0] M_AXI_WDATA,
  output [3:0]  M_AXI_WSTRB,
  output        M_AXI_WVALID,
  input         M_AXI_WREADY,
  input  [1:0]  M_AXI_BRESP,
  input         M_AXI_BVALID,
  output        M_AXI_BREADY,
  output [31:0] M_AXI_ARADDR,
  output [2:0]  M_AXI_ARPROT,
  output        M_AXI_ARVALID,
  input         M_AXI_ARREADY,
  input  [31:0] M_AXI_RDATA,
  input  [1:0]  M_AXI_RRESP,
  input         M_AXI_RVALID,
  output        M_AXI_RREADY,
                TX,
  input         RX,
  output        CMD_VALID,
                CMD_TYPE
);

  wire        _uart_cmd_UART_CMD_cmd_valid;
  wire        _uart_cmd_UART_CMD_cmd_type;
  wire [31:0] _uart_cmd_UART_CMD_cmd_addr;
  wire [31:0] _uart_cmd_UART_CMD_cmd_wdata;
  reg  [2:0]  state;
  reg  [31:0] axi_awaddr;
  reg         axi_awvalid;
  reg  [31:0] axi_wdata;
  reg         axi_wvalid;
  reg         axi_bready;
  reg  [31:0] axi_araddr;
  reg         axi_arvalid;
  reg         axi_rready;
  reg         aw_done;
  reg         w_done;
  wire        _GEN = state == 3'h0;
  wire        _GEN_0 = state == 3'h1;
  wire        _GEN_1 = state == 3'h3;
  wire        _GEN_2 = M_AXI_BVALID & axi_bready;
  wire        _GEN_3 = state == 3'h4;
  wire        _GEN_4 = state == 3'h5;
  wire        _GEN_5 = M_AXI_RVALID & axi_rready;
  wire        _GEN_6 = _GEN_4 & _GEN_5;
  wire        _GEN_7 = aw_done & w_done;
  wire        _GEN_8 = _GEN_0 & M_AXI_AWREADY & axi_awvalid;
  wire        _GEN_9 = _GEN_0 & M_AXI_WREADY & axi_wvalid;
  wire        _GEN_10 = _uart_cmd_UART_CMD_cmd_valid & ~_uart_cmd_UART_CMD_cmd_type;
  wire        _GEN_11 = M_AXI_ARREADY & axi_arvalid;
  wire        _GEN_12 = _GEN_0 | _GEN_1;
  always @(posedge clock) begin
    if (reset) begin
      state <= 3'h0;
      axi_awaddr <= 32'h0;
      axi_awvalid <= 1'h0;
      axi_wdata <= 32'h0;
      axi_wvalid <= 1'h0;
      axi_bready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arvalid <= 1'h0;
      axi_rready <= 1'h0;
      aw_done <= 1'h0;
      w_done <= 1'h0;
    end
    else begin
      if (_GEN) begin
        if (_uart_cmd_UART_CMD_cmd_valid)
          state <= _uart_cmd_UART_CMD_cmd_type ? 3'h4 : 3'h1;
        axi_awvalid <= _GEN_10 | axi_awvalid;
        axi_wvalid <= _GEN_10 | axi_wvalid;
        axi_arvalid <=
          _uart_cmd_UART_CMD_cmd_valid & _uart_cmd_UART_CMD_cmd_type | axi_arvalid;
        aw_done <= ~_GEN_10 & aw_done;
        w_done <= ~_GEN_10 & w_done;
      end
      else begin
        if (_GEN_0) begin
          if (_GEN_7)
            state <= 3'h3;
          axi_bready <= _GEN_7 | axi_bready;
        end
        else begin
          if (_GEN_1) begin
            if (_GEN_2)
              state <= 3'h0;
          end
          else if (_GEN_3) begin
            if (_GEN_11)
              state <= 3'h5;
          end
          else if (_GEN_6)
            state <= 3'h0;
          axi_bready <= ~(_GEN_1 & _GEN_2) & axi_bready;
        end
        axi_awvalid <= ~_GEN_8 & axi_awvalid;
        axi_wvalid <= ~_GEN_9 & axi_wvalid;
        axi_arvalid <= (_GEN_12 | ~(_GEN_3 & _GEN_11)) & axi_arvalid;
        aw_done <= _GEN_8 | aw_done;
        w_done <= _GEN_9 | w_done;
      end
      if (_GEN & _GEN_10) begin
        axi_awaddr <= _uart_cmd_UART_CMD_cmd_addr;
        axi_wdata <= _uart_cmd_UART_CMD_cmd_wdata;
      end
      if (_GEN & _uart_cmd_UART_CMD_cmd_valid & _uart_cmd_UART_CMD_cmd_type)
        axi_araddr <= _uart_cmd_UART_CMD_cmd_addr;
      if (~(_GEN | _GEN_12)) begin
        if (_GEN_3)
          axi_rready <= _GEN_11 | axi_rready;
        else
          axi_rready <= ~_GEN_6 & axi_rready;
      end
    end
  end // always @(posedge)
  uart_cmd_byte_level_b115200_f100000000 uart_cmd (
    .clock               (clock),
    .reset               (reset),
    .UART_CMD_txd        (TX),
    .UART_CMD_rxd        (RX),
    .UART_CMD_cmd_valid  (_uart_cmd_UART_CMD_cmd_valid),
    .UART_CMD_cmd_type   (_uart_cmd_UART_CMD_cmd_type),
    .UART_CMD_cmd_addr   (_uart_cmd_UART_CMD_cmd_addr),
    .UART_CMD_cmd_wdata  (_uart_cmd_UART_CMD_cmd_wdata),
    .UART_CMD_resp_valid
      (~(_GEN | _GEN_0) & (_GEN_1 ? _GEN_2 : ~_GEN_3 & _GEN_4 & _GEN_5)),
    .UART_CMD_resp_rdata (_GEN | _GEN_0 | _GEN_1 | _GEN_3 | ~_GEN_6 ? 32'h0 : M_AXI_RDATA)
  );
  assign M_AXI_AWADDR = axi_awaddr;
  assign M_AXI_AWPROT = 3'h0;
  assign M_AXI_AWVALID = axi_awvalid;
  assign M_AXI_WDATA = axi_wdata;
  assign M_AXI_WSTRB = 4'hF;
  assign M_AXI_WVALID = axi_wvalid;
  assign M_AXI_BREADY = axi_bready;
  assign M_AXI_ARADDR = axi_araddr;
  assign M_AXI_ARPROT = 3'h0;
  assign M_AXI_ARVALID = axi_arvalid;
  assign M_AXI_RREADY = axi_rready;
  assign CMD_VALID = _uart_cmd_UART_CMD_cmd_valid;
  assign CMD_TYPE = _uart_cmd_UART_CMD_cmd_type;
endmodule

