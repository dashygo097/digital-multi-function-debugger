`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module axilite_master_32x32(
  input         clock,
                reset,
  output [31:0] M_AXI_AWADDR,
  output [2:0]  M_AXI_AWPROT,
  output        M_AXI_AWVALID,
  input         M_AXI_AWREADY,
  output [31:0] M_AXI_WDATA,
  output [3:0]  M_AXI_WSTRB,
  output        M_AXI_WVALID,
  input         M_AXI_WREADY,
  input  [1:0]  M_AXI_BRESP,
  input         M_AXI_BVALID,
  output        M_AXI_BREADY,
  output [31:0] M_AXI_ARADDR,
  output [2:0]  M_AXI_ARPROT,
  output        M_AXI_ARVALID,
  input         M_AXI_ARREADY,
  input  [31:0] M_AXI_RDATA,
  input  [1:0]  M_AXI_RRESP,
  input         M_AXI_RVALID,
  output        M_AXI_RREADY,
  input  [31:0] W_DATA,
                W_ADDR,
  input         W_EN,
  output        W_READY,
  output [1:0]  W_RESP,
  output [31:0] R_DATA,
  input  [31:0] R_ADDR,
  input         R_EN,
  output        R_READY,
  output [1:0]  R_RESP
);

  reg  [31:0] axi_awaddr;
  reg         axi_awvalid;
  reg  [31:0] axi_wdata;
  reg         axi_wvalid;
  reg         axi_bready;
  reg  [31:0] axi_araddr;
  reg         axi_arvalid;
  reg         axi_rready;
  wire        _W_READY_T = M_AXI_WREADY & axi_wvalid;
  wire        _GEN = M_AXI_RVALID & ~axi_rready;
  reg  [31:0] R_DATA_REG;
  always @(posedge clock) begin
    if (reset) begin
      axi_awaddr <= 32'h0;
      axi_awvalid <= 1'h0;
      axi_wdata <= 32'h0;
      axi_wvalid <= 1'h0;
      axi_bready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arvalid <= 1'h0;
      axi_rready <= 1'h0;
    end
    else begin
      automatic logic _GEN_0 = W_EN & ~axi_awvalid;
      automatic logic _GEN_1 = W_EN & ~axi_wvalid;
      automatic logic _GEN_2 = R_EN & ~axi_arvalid;
      if (_GEN_0)
        axi_awaddr <= W_ADDR;
      axi_awvalid <= _GEN_0 | ~(M_AXI_AWREADY & axi_awvalid) & axi_awvalid;
      if (_GEN_1)
        axi_wdata <= W_DATA;
      axi_wvalid <= _GEN_1 | ~_W_READY_T & axi_wvalid;
      axi_bready <= M_AXI_BVALID & ~axi_bready;
      if (_GEN_2)
        axi_araddr <= R_ADDR;
      axi_arvalid <= _GEN_2 | ~(M_AXI_ARREADY & axi_arvalid) & axi_arvalid;
      axi_rready <= _GEN;
    end
    if (_GEN)
      R_DATA_REG <= M_AXI_RDATA;
    else if (axi_rready) begin
    end
    else
      R_DATA_REG <= 32'h0;
  end // always @(posedge)
  assign M_AXI_AWADDR = axi_awaddr;
  assign M_AXI_AWPROT = 3'h0;
  assign M_AXI_AWVALID = axi_awvalid;
  assign M_AXI_WDATA = axi_wdata;
  assign M_AXI_WSTRB = 4'hF;
  assign M_AXI_WVALID = axi_wvalid;
  assign M_AXI_BREADY = axi_bready;
  assign M_AXI_ARADDR = axi_araddr;
  assign M_AXI_ARPROT = 3'h0;
  assign M_AXI_ARVALID = axi_arvalid;
  assign M_AXI_RREADY = axi_rready;
  assign W_READY = _W_READY_T;
  assign W_RESP = M_AXI_BRESP;
  assign R_DATA = _GEN ? M_AXI_RDATA : axi_rready ? R_DATA_REG : 32'h0;
  assign R_READY = M_AXI_RVALID & axi_rready;
  assign R_RESP = M_AXI_RRESP;
endmodule

