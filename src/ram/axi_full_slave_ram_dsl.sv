`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module axi_full_slave_ram_32x32_i4_u1(
  input         clock,
                reset,
  input  [31:0] S_AXI_AWADDR,
  input  [2:0]  S_AXI_AWPROT,
  input         S_AXI_AWVALID,
  output        S_AXI_AWREADY,
  input  [3:0]  S_AXI_AWID,
  input  [7:0]  S_AXI_AWLEN,
  input  [2:0]  S_AXI_AWSIZE,
  input  [1:0]  S_AXI_AWBURST,
  input         S_AXI_AWLOCK,
  input  [3:0]  S_AXI_AWCACHE,
                S_AXI_AWQOS,
                S_AXI_AWREGION,
  input         S_AXI_AWUSER,
  input  [31:0] S_AXI_WDATA,
  input  [3:0]  S_AXI_WSTRB,
  input         S_AXI_WVALID,
  output        S_AXI_WREADY,
  input         S_AXI_WLAST,
  input  [3:0]  S_AXI_WID,
  input         S_AXI_WUSER,
                S_AXI_BREADY,
  output [1:0]  S_AXI_BRESP,
  output        S_AXI_BVALID,
  output [3:0]  S_AXI_BID,
  output        S_AXI_BUSER,
  input  [31:0] S_AXI_ARADDR,
  input  [2:0]  S_AXI_ARPROT,
  input         S_AXI_ARVALID,
  output        S_AXI_ARREADY,
  input  [3:0]  S_AXI_ARID,
  input  [7:0]  S_AXI_ARLEN,
  input  [2:0]  S_AXI_ARSIZE,
  input  [1:0]  S_AXI_ARBURST,
  input         S_AXI_ARLOCK,
  input  [3:0]  S_AXI_ARCACHE,
                S_AXI_ARQOS,
                S_AXI_ARREGION,
  input         S_AXI_ARUSER,
                S_AXI_RREADY,
  output [31:0] S_AXI_RDATA,
  output [1:0]  S_AXI_RRESP,
  output        S_AXI_RVALID,
                S_AXI_RLAST,
  output [3:0]  S_AXI_RID,
  output        S_AXI_RUSER
);

  wire [3:0]        _mem_addr_T_3;
  reg               axi_awready;
  reg               axi_awv_awr_flag;
  reg  [31:0]       axi_awaddr;
  reg  [1:0]        axi_awburst;
  reg  [7:0]        axi_awlen;
  reg  [7:0]        axi_awlen_cntr;
  reg               axi_wready;
  reg               axi_bvalid;
  reg               axi_arready;
  reg  [31:0]       axi_araddr;
  reg  [1:0]        axi_arburst;
  reg  [7:0]        axi_arlen;
  reg  [7:0]        axi_arlen_cntr;
  reg               axi_arv_arr_flag;
  reg               axi_rvalid;
  reg               axi_rlast;
  reg  [31:0]       ram_0;
  reg  [31:0]       ram_1;
  reg  [31:0]       ram_2;
  reg  [31:0]       ram_3;
  reg  [31:0]       ram_4;
  reg  [31:0]       ram_5;
  reg  [31:0]       ram_6;
  reg  [31:0]       ram_7;
  reg  [31:0]       ram_8;
  reg  [31:0]       ram_9;
  reg  [31:0]       ram_10;
  reg  [31:0]       ram_11;
  reg  [31:0]       ram_12;
  reg  [31:0]       ram_13;
  reg  [31:0]       ram_14;
  reg  [31:0]       ram_15;
  wire [15:0][31:0] _GEN =
    {{ram_15},
     {ram_14},
     {ram_13},
     {ram_12},
     {ram_11},
     {ram_10},
     {ram_9},
     {ram_8},
     {ram_7},
     {ram_6},
     {ram_5},
     {ram_4},
     {ram_3},
     {ram_2},
     {ram_1},
     {ram_0}};
  wire [31:0]       data_out = _GEN[_mem_addr_T_3];
  assign _mem_addr_T_3 =
    axi_arv_arr_flag ? axi_araddr[5:2] : axi_awv_awr_flag ? axi_awaddr[5:2] : 4'h0;
  always @(posedge clock) begin
    if (reset) begin
      axi_awready <= 1'h0;
      axi_awv_awr_flag <= 1'h0;
      axi_awaddr <= 32'h0;
      axi_awburst <= 2'h0;
      axi_awlen <= 8'h0;
      axi_awlen_cntr <= 8'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arburst <= 2'h0;
      axi_arlen <= 8'h0;
      axi_arlen_cntr <= 8'h0;
      axi_arv_arr_flag <= 1'h0;
      axi_rvalid <= 1'h0;
      axi_rlast <= 1'h0;
      ram_0 <= 32'h0;
      ram_1 <= 32'h0;
      ram_2 <= 32'h0;
      ram_3 <= 32'h0;
      ram_4 <= 32'h0;
      ram_5 <= 32'h0;
      ram_6 <= 32'h0;
      ram_7 <= 32'h0;
      ram_8 <= 32'h0;
      ram_9 <= 32'h0;
      ram_10 <= 32'h0;
      ram_11 <= 32'h0;
      ram_12 <= 32'h0;
      ram_13 <= 32'h0;
      ram_14 <= 32'h0;
      ram_15 <= 32'h0;
    end
    else begin
      automatic logic        mem_we = axi_wready & S_AXI_WVALID;
      automatic logic        _GEN_0 = ~axi_awready & S_AXI_AWVALID & ~axi_awv_awr_flag;
      automatic logic        _GEN_1 = _GEN_0 & ~axi_arv_arr_flag;
      automatic logic        _GEN_2 = S_AXI_WLAST & axi_wready;
      automatic logic        _GEN_3 = ~axi_arready & S_AXI_ARVALID;
      automatic logic        _GEN_4 = _GEN_3 & ~axi_awv_awr_flag & ~axi_arv_arr_flag;
      automatic logic        _GEN_5 = axi_rvalid & S_AXI_RREADY;
      automatic logic        _GEN_6 = axi_arlen_cntr == axi_arlen;
      automatic logic        _GEN_7 = _GEN_5 & _GEN_6;
      automatic logic        _GEN_8 = _GEN_3 & ~axi_arv_arr_flag;
      automatic logic        _GEN_9;
      automatic logic [31:0] _ram_T_12;
      _GEN_9 = axi_arlen_cntr <= axi_arlen & axi_rvalid & S_AXI_RREADY;
      _ram_T_12 =
        {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : data_out[31:24],
         S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : data_out[23:16],
         S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : data_out[15:8],
         S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : data_out[7:0]};
      axi_awready <= _GEN_1 | _GEN_2 & axi_awready;
      axi_awv_awr_flag <= _GEN_1 | ~_GEN_2 & axi_awv_awr_flag;
      if (_GEN_0) begin
        axi_awaddr <= S_AXI_AWADDR;
        axi_awburst <= S_AXI_AWBURST;
        axi_awlen <= S_AXI_AWLEN;
        axi_awlen_cntr <= 8'h0;
      end
      else if (axi_awlen_cntr <= axi_awlen & axi_wready & S_AXI_WVALID) begin
        automatic logic [31:0]      aw_wrap_size = {22'h0, axi_awlen, 2'h0};
        automatic logic [3:0][31:0] _GEN_10 =
          {{{2'h0, axi_awaddr[31:2] + 30'h1}},
           {(axi_awaddr & aw_wrap_size) == aw_wrap_size
              ? axi_awaddr - {22'h0, axi_awlen, 2'h0}
              : {axi_awaddr[31:2] + 30'h1, 2'h0}},
           {{axi_awaddr[31:2] + 30'h1, 2'h0}},
           {axi_awaddr}};
        axi_awaddr <= _GEN_10[axi_awburst];
        axi_awlen_cntr <= axi_awlen_cntr + 8'h1;
      end
      axi_wready <= ~axi_wready & S_AXI_WVALID & axi_awv_awr_flag | ~_GEN_2 & axi_wready;
      axi_bvalid <=
        axi_awv_awr_flag & axi_wready & S_AXI_WVALID & ~axi_bvalid & S_AXI_WLAST
        | ~(S_AXI_BREADY & axi_bvalid) & axi_bvalid;
      axi_arready <= _GEN_4 | _GEN_7 & axi_arready;
      if (_GEN_8) begin
        axi_araddr <= S_AXI_ARADDR;
        axi_arburst <= S_AXI_ARBURST;
        axi_arlen <= S_AXI_ARLEN;
        axi_arlen_cntr <= 8'h0;
      end
      else if (_GEN_9) begin
        automatic logic [31:0]      ar_wrap_size = {22'h0, axi_arlen, 2'h0};
        automatic logic [3:0][31:0] _GEN_11 =
          {{{2'h0, S_AXI_ARADDR[31:2] + 30'h1}},
           {(axi_awaddr & ar_wrap_size) == ar_wrap_size
              ? axi_araddr - {22'h0, axi_arlen, 2'h0}
              : {axi_araddr[31:2] + 30'h1, 2'h0}},
           {{axi_araddr[31:2] + 30'h1, 2'h0}},
           {axi_araddr}};
        axi_araddr <= _GEN_11[axi_arburst];
        axi_arlen_cntr <= axi_arlen_cntr + 8'h1;
      end
      axi_arv_arr_flag <= _GEN_4 | ~_GEN_7 & axi_arv_arr_flag;
      axi_rvalid <= axi_arv_arr_flag & ~axi_rvalid | ~_GEN_5 & axi_rvalid;
      axi_rlast <=
        ~(_GEN_8 | _GEN_9)
        & (_GEN_6 & ~axi_rlast & axi_arv_arr_flag | ~S_AXI_RREADY & axi_rlast);
      if (mem_we & _mem_addr_T_3 == 4'h0)
        ram_0 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h1)
        ram_1 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h2)
        ram_2 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h3)
        ram_3 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h4)
        ram_4 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h5)
        ram_5 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h6)
        ram_6 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h7)
        ram_7 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h8)
        ram_8 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'h9)
        ram_9 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'hA)
        ram_10 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'hB)
        ram_11 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'hC)
        ram_12 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'hD)
        ram_13 <= _ram_T_12;
      if (mem_we & _mem_addr_T_3 == 4'hE)
        ram_14 <= _ram_T_12;
      if (mem_we & (&_mem_addr_T_3))
        ram_15 <= _ram_T_12;
    end
  end // always @(posedge)
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY = axi_wready;
  assign S_AXI_BRESP = 2'h0;
  assign S_AXI_BVALID = axi_bvalid;
  assign S_AXI_BID = S_AXI_AWID;
  assign S_AXI_BUSER = 1'h0;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA = axi_rvalid ? data_out : 32'h0;
  assign S_AXI_RRESP = 2'h0;
  assign S_AXI_RVALID = axi_rvalid;
  assign S_AXI_RLAST = axi_rlast;
  assign S_AXI_RID = S_AXI_ARID;
  assign S_AXI_RUSER = 1'h0;
endmodule

