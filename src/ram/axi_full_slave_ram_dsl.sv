`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module axifull_slave_ram_8x32x32_i4_u1(
  input         clock,
                reset,
  input  [31:0] S_AXI_AWADDR,
  input  [2:0]  S_AXI_AWPROT,
  input         S_AXI_AWVALID,
  output        S_AXI_AWREADY,
  input  [3:0]  S_AXI_AWID,
  input  [7:0]  S_AXI_AWLEN,
  input  [2:0]  S_AXI_AWSIZE,
  input  [1:0]  S_AXI_AWBURST,
  input         S_AXI_AWLOCK,
  input  [3:0]  S_AXI_AWCACHE,
                S_AXI_AWQOS,
                S_AXI_AWREGION,
  input         S_AXI_AWUSER,
  input  [31:0] S_AXI_WDATA,
  input  [3:0]  S_AXI_WSTRB,
  input         S_AXI_WVALID,
  output        S_AXI_WREADY,
  input         S_AXI_WLAST,
  input  [3:0]  S_AXI_WID,
  input         S_AXI_WUSER,
                S_AXI_BREADY,
  output [1:0]  S_AXI_BRESP,
  output        S_AXI_BVALID,
  output [3:0]  S_AXI_BID,
  output        S_AXI_BUSER,
  input  [31:0] S_AXI_ARADDR,
  input  [2:0]  S_AXI_ARPROT,
  input         S_AXI_ARVALID,
  output        S_AXI_ARREADY,
  input  [3:0]  S_AXI_ARID,
  input  [7:0]  S_AXI_ARLEN,
  input  [2:0]  S_AXI_ARSIZE,
  input  [1:0]  S_AXI_ARBURST,
  input         S_AXI_ARLOCK,
  input  [3:0]  S_AXI_ARCACHE,
                S_AXI_ARQOS,
                S_AXI_ARREGION,
  input         S_AXI_ARUSER,
                S_AXI_RREADY,
  output [31:0] S_AXI_RDATA,
  output [1:0]  S_AXI_RRESP,
  output        S_AXI_RVALID,
                S_AXI_RLAST,
  output [3:0]  S_AXI_RID,
  output        S_AXI_RUSER
);

  wire [2:0]       _mem_addr_T_3;
  reg              axi_awready;
  reg              axi_awv_awr_flag;
  reg  [31:0]      axi_awaddr;
  reg  [1:0]       axi_awburst;
  reg  [7:0]       axi_awlen;
  reg  [7:0]       axi_awlen_cntr;
  reg              axi_wready;
  reg              axi_bvalid;
  reg  [1:0]       axi_bresp;
  reg              axi_arready;
  reg  [31:0]      axi_araddr;
  reg  [1:0]       axi_arburst;
  reg  [7:0]       axi_arlen;
  reg  [7:0]       axi_arlen_cntr;
  reg              axi_arv_arr_flag;
  reg              axi_rvalid;
  reg  [1:0]       axi_rresp;
  reg              axi_rlast;
  reg              addr_error;
  reg  [31:0]      ram_0;
  reg  [31:0]      ram_1;
  reg  [31:0]      ram_2;
  reg  [31:0]      ram_3;
  reg  [31:0]      ram_4;
  reg  [31:0]      ram_5;
  reg  [31:0]      ram_6;
  reg  [31:0]      ram_7;
  wire [31:0]      _aw_offset_addr_T = axi_awaddr - 32'h10000;
  wire [31:0]      _ar_offset_addr_T = axi_araddr - 32'h10000;
  wire             ar_addr_valid = (|(axi_araddr[31:16])) & _ar_offset_addr_T < 32'h20;
  wire [7:0][31:0] _GEN =
    {{ram_7}, {ram_6}, {ram_5}, {ram_4}, {ram_3}, {ram_2}, {ram_1}, {ram_0}};
  wire [31:0]      data_out = _GEN[_mem_addr_T_3];
  assign _mem_addr_T_3 =
    axi_arv_arr_flag
      ? _ar_offset_addr_T[4:2]
      : axi_awv_awr_flag ? _aw_offset_addr_T[4:2] : 3'h0;
  always @(posedge clock) begin
    if (reset) begin
      axi_awready <= 1'h0;
      axi_awv_awr_flag <= 1'h0;
      axi_awaddr <= 32'h0;
      axi_awburst <= 2'h0;
      axi_awlen <= 8'h0;
      axi_awlen_cntr <= 8'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_bresp <= 2'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arburst <= 2'h0;
      axi_arlen <= 8'h0;
      axi_arlen_cntr <= 8'h0;
      axi_arv_arr_flag <= 1'h0;
      axi_rvalid <= 1'h0;
      axi_rresp <= 2'h0;
      axi_rlast <= 1'h0;
      addr_error <= 1'h0;
      ram_0 <= 32'h0;
      ram_1 <= 32'h0;
      ram_2 <= 32'h0;
      ram_3 <= 32'h0;
      ram_4 <= 32'h0;
      ram_5 <= 32'h0;
      ram_6 <= 32'h0;
      ram_7 <= 32'h0;
    end
    else begin
      automatic logic        aw_addr_valid;
      automatic logic        _GEN_0 = ~axi_awready & S_AXI_AWVALID & ~axi_awv_awr_flag;
      automatic logic        _GEN_1;
      automatic logic        _GEN_2 = S_AXI_WLAST & axi_wready;
      automatic logic        _GEN_3 =
        axi_awv_awr_flag & axi_wready & S_AXI_WVALID & ~axi_bvalid & S_AXI_WLAST;
      automatic logic        _GEN_4 = ~axi_arready & S_AXI_ARVALID;
      automatic logic        _GEN_5 = _GEN_4 & ~axi_awv_awr_flag & ~axi_arv_arr_flag;
      automatic logic        _GEN_6 = axi_rvalid & S_AXI_RREADY;
      automatic logic        _GEN_7 = axi_arlen_cntr == axi_arlen;
      automatic logic        _GEN_8 = _GEN_6 & _GEN_7;
      automatic logic        _GEN_9 = _GEN_4 & ~axi_arv_arr_flag;
      automatic logic        _GEN_10;
      automatic logic        _GEN_11 = axi_arv_arr_flag & ~axi_rvalid;
      automatic logic        _GEN_12;
      automatic logic [31:0] _ram_T_12;
      aw_addr_valid = (|(axi_awaddr[31:16])) & _aw_offset_addr_T < 32'h20;
      _GEN_1 = _GEN_0 & ~axi_arv_arr_flag;
      _GEN_10 = axi_arlen_cntr <= axi_arlen & axi_rvalid & S_AXI_RREADY;
      _GEN_12 = axi_wready & S_AXI_WVALID & aw_addr_valid;
      _ram_T_12 =
        {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : data_out[31:24],
         S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : data_out[23:16],
         S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : data_out[15:8],
         S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : data_out[7:0]};
      axi_awready <= _GEN_1 | _GEN_2 & axi_awready;
      axi_awv_awr_flag <= _GEN_1 | ~_GEN_2 & axi_awv_awr_flag;
      if (_GEN_0) begin
        axi_awaddr <= S_AXI_AWADDR;
        axi_awburst <= S_AXI_AWBURST;
        axi_awlen <= S_AXI_AWLEN;
        axi_awlen_cntr <= 8'h0;
      end
      else if (axi_awlen_cntr <= axi_awlen & axi_wready & S_AXI_WVALID) begin
        automatic logic [31:0]      aw_wrap_size = {22'h0, axi_awlen, 2'h0};
        automatic logic [3:0][31:0] _GEN_13 =
          {{{2'h0, axi_awaddr[31:2] + 30'h1}},
           {(axi_awaddr & aw_wrap_size) == aw_wrap_size
              ? axi_awaddr - {22'h0, axi_awlen, 2'h0}
              : {axi_awaddr[31:2] + 30'h1, 2'h0}},
           {{axi_awaddr[31:2] + 30'h1, 2'h0}},
           {axi_awaddr}};
        axi_awaddr <= _GEN_13[axi_awburst];
        axi_awlen_cntr <= axi_awlen_cntr + 8'h1;
      end
      axi_wready <= ~axi_wready & S_AXI_WVALID & axi_awv_awr_flag | ~_GEN_2 & axi_wready;
      axi_bvalid <= _GEN_3 | ~(S_AXI_BREADY & axi_bvalid) & axi_bvalid;
      if (_GEN_3)
        axi_bresp <= {addr_error, 1'h0};
      axi_arready <= _GEN_5 | _GEN_8 & axi_arready;
      if (_GEN_9) begin
        axi_araddr <= S_AXI_ARADDR;
        axi_arburst <= S_AXI_ARBURST;
        axi_arlen <= S_AXI_ARLEN;
        axi_arlen_cntr <= 8'h0;
      end
      else if (_GEN_10) begin
        automatic logic [31:0]      ar_wrap_size = {22'h0, axi_arlen, 2'h0};
        automatic logic [3:0][31:0] _GEN_14 =
          {{{2'h0, S_AXI_ARADDR[31:2] + 30'h1}},
           {(axi_awaddr & ar_wrap_size) == ar_wrap_size
              ? axi_araddr - {22'h0, axi_arlen, 2'h0}
              : {axi_araddr[31:2] + 30'h1, 2'h0}},
           {{axi_araddr[31:2] + 30'h1, 2'h0}},
           {axi_araddr}};
        axi_araddr <= _GEN_14[axi_arburst];
        axi_arlen_cntr <= axi_arlen_cntr + 8'h1;
      end
      axi_arv_arr_flag <= _GEN_5 | ~_GEN_8 & axi_arv_arr_flag;
      axi_rvalid <= _GEN_11 | ~_GEN_6 & axi_rvalid;
      if (_GEN_11)
        axi_rresp <= {addr_error, 1'h0};
      axi_rlast <=
        ~(_GEN_9 | _GEN_10)
        & (_GEN_7 & ~axi_rlast & axi_arv_arr_flag | ~S_AXI_RREADY & axi_rlast);
      if (_GEN_5)
        addr_error <= ~ar_addr_valid;
      else if (_GEN_1)
        addr_error <= ~aw_addr_valid;
      if (_GEN_12 & _mem_addr_T_3 == 3'h0)
        ram_0 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h1)
        ram_1 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h2)
        ram_2 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h3)
        ram_3 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h4)
        ram_4 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h5)
        ram_5 <= _ram_T_12;
      if (_GEN_12 & _mem_addr_T_3 == 3'h6)
        ram_6 <= _ram_T_12;
      if (_GEN_12 & (&_mem_addr_T_3))
        ram_7 <= _ram_T_12;
    end
  end // always @(posedge)
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY = axi_wready;
  assign S_AXI_BRESP = axi_bresp;
  assign S_AXI_BVALID = axi_bvalid;
  assign S_AXI_BID = S_AXI_AWID;
  assign S_AXI_BUSER = 1'h0;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA = axi_rvalid & ar_addr_valid ? data_out : 32'h0;
  assign S_AXI_RRESP = axi_rresp;
  assign S_AXI_RVALID = axi_rvalid;
  assign S_AXI_RLAST = axi_rlast;
  assign S_AXI_RID = S_AXI_ARID;
  assign S_AXI_RUSER = 1'h0;
endmodule

