`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.128.0
module uart_tx_b115200_f100000000 (
    input        clock,
    reset,
    output       UART_TX_txd,
    UART_TX_channel_ready,
    input        UART_TX_channel_valid,
    input  [7:0] UART_TX_channel_bits
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  wire       UART_TX_channel_ready_0 = state == 2'h0;
  wire       _GEN = state == 2'h1;
  wire       _GEN_0 = state == 2'h2;
  always @(posedge clock) begin
    automatic logic tick;
    automatic logic _GEN_1;
    tick   = tickCounter == 10'h363;
    _GEN_1 = _GEN_0 & tick;
    if (reset) begin
      state <= 2'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end else begin
      automatic logic [3:0][1:0] _GEN_2;
      _GEN_2 = {
        {(&state) & tick ? 2'h0 : state},
        {tick & (&bitCounter) ? 2'h3 : state},
        {tick ? 2'h2 : state},
        {UART_TX_channel_valid ? 2'h1 : state}
      };
      state <= _GEN_2[state];
      if (~UART_TX_channel_ready_0) begin
        if (_GEN) begin
          if (tick) bitCounter <= 3'h0;
        end else
        if (~_GEN_1 | (&bitCounter)) begin
        end else bitCounter <= bitCounter + 3'h1;
      end
      tickCounter <=
        UART_TX_channel_ready_0 & UART_TX_channel_valid | tick
          ? 10'h0
          : tickCounter + 10'h1;
    end
    if (UART_TX_channel_ready_0) begin
      if (UART_TX_channel_valid) data <= UART_TX_channel_bits;
    end else
    if (_GEN | ~_GEN_1 | (&bitCounter)) begin
    end else data <= {1'h0, data[7:1]};
  end  // always @(posedge)
  assign UART_TX_txd = UART_TX_channel_ready_0 | ~_GEN & (~_GEN_0 | data[0]);
  assign UART_TX_channel_ready = UART_TX_channel_ready_0;
endmodule

module uart_rx_b115200_f100000000 (
    input        clock,
    reset,
    UART_RX_rxd,
    output       UART_RX_channel_valid,
    output [7:0] UART_RX_channel_bits,
    output       UART_RX_error
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  wire       tick = tickCounter == 10'h363;
  reg        rxd_REG;
  reg        rxd;
  wire       _GEN = state == 2'h0;
  wire       _GEN_0 = state == 2'h1;
  wire       _GEN_1 = state == 2'h2;
  wire       _GEN_2 = _GEN | _GEN_0 | _GEN_1;
  wire       _GEN_3 = (&state) & tick;
  always @(posedge clock) begin
    automatic logic _GEN_4;
    _GEN_4 = _GEN_1 & tick;
    if (reset) begin
      state <= 2'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end else begin
      automatic
      logic [3:0][1:0]
      _GEN_5 = {
        {_GEN_3 ? 2'h0 : state},
        {tick & (&bitCounter) ? 2'h3 : state},
        {tick ? {~rxd, 1'h0} : state},
        {rxd ? state : 2'h1}
      };
      state <= _GEN_5[state];
      if (~_GEN) begin
        if (_GEN_0) begin
          if (tick & ~rxd) bitCounter <= 3'h0;
        end else
        if (~_GEN_4 | (&bitCounter)) begin
        end else bitCounter <= bitCounter + 3'h1;
      end
      tickCounter <= _GEN & ~rxd ? 10'h1B2 : tick ? 10'h0 : tickCounter + 10'h1;
    end
    if (_GEN | _GEN_0 | ~_GEN_4) begin
    end else data <= {rxd, data[7:1]};
    rxd_REG <= UART_RX_rxd;
    rxd <= rxd_REG;
  end  // always @(posedge)
  assign UART_RX_channel_valid = ~_GEN_2 & (&state) & tick;
  assign UART_RX_channel_bits = _GEN_2 | ~_GEN_3 ? 8'h0 : data;
  assign UART_RX_error = ~_GEN_2 & _GEN_3 & ~rxd;
endmodule

module uart_level_b115200_f100000000 (
    input         clock,
    reset,
    output        UART_CMD_txd,
    input         UART_CMD_rxd,
    output        UART_CMD_cmd_valid,
    output [ 1:0] UART_CMD_cmd_type,
    output [31:0] UART_CMD_cmd_addr,
    UART_CMD_cmd_wdata,
    input         UART_CMD_resp_valid,
    input  [31:0] UART_CMD_resp_rdata
);

  wire _uart_rx_UART_RX_channel_valid;
  wire [7:0] _uart_rx_UART_RX_channel_bits;
  wire _uart_rx_UART_RX_error;
  wire _uart_tx_UART_TX_channel_ready;
  wire [2:0][7:0] _GEN = '{8'h0, 8'h0, 8'h0};
  reg [1:0] rx_state;
  reg [3:0] rx_byte_cnt;
  reg [7:0] rx_buffer_0;
  reg [7:0] rx_buffer_1;
  reg [7:0] rx_buffer_2;
  reg [7:0] rx_buffer_3;
  reg [7:0] rx_buffer_4;
  reg [7:0] rx_buffer_5;
  reg [7:0] rx_buffer_6;
  reg [7:0] rx_buffer_7;
  reg cmd_valid_reg;
  reg [1:0] cmd_type_reg;
  reg [31:0] cmd_addr_reg;
  reg [31:0] cmd_wdata_reg;
  reg [1:0] tx_state;
  reg [2:0] tx_byte_cnt;
  reg [7:0] tx_buffer_1;
  reg [7:0] tx_buffer_2;
  reg [7:0] tx_buffer_3;
  reg [7:0] tx_buffer_4;
  reg [3:0] tx_total_bytes;
  wire _GEN_0 = tx_state == 2'h0;
  wire _GEN_1 = tx_state == 2'h1;
  wire [7:0][7:0] _GEN_2 = {
    _GEN, {{tx_buffer_4}, {tx_buffer_3}, {tx_buffer_2}, {tx_buffer_1}, {8'h0}}
  };
  always @(posedge clock) begin
    automatic logic       _GEN_3;
    automatic logic       _GEN_4;
    automatic logic       _GEN_5;
    automatic logic [3:0] _next_byte_cnt_T;
    automatic logic       _GEN_6;
    automatic logic       _GEN_7;
    automatic logic       _GEN_8;
    automatic logic       _GEN_9;
    _GEN_3 = rx_state == 2'h0;
    _GEN_4 = _uart_rx_UART_RX_channel_valid & ~_uart_rx_UART_RX_error;
    _GEN_5 = rx_state == 2'h1;
    _next_byte_cnt_T = rx_byte_cnt + 4'h1;
    _GEN_6 = _next_byte_cnt_T == 4'h9;
    _GEN_7 = _GEN_5 & _GEN_4 & _GEN_6;
    _GEN_8 = _GEN_3 | ~_GEN_7;
    _GEN_9 = _GEN_0 & UART_CMD_resp_valid;
    if (reset) begin
      rx_state <= 2'h0;
      rx_byte_cnt <= 4'h0;
      cmd_valid_reg <= 1'h0;
      cmd_addr_reg <= 32'h0;
      cmd_wdata_reg <= 32'h0;
      tx_state <= 2'h0;
      tx_byte_cnt <= 3'h0;
      tx_total_bytes <= 4'h0;
    end else begin
      if (_GEN_3) begin
        if (_GEN_4) begin
          rx_state <= 2'h1;
          rx_byte_cnt <= 4'h1;
        end
      end else begin
        if (_GEN_7) rx_state <= 2'h0;
        if (_GEN_5 & _GEN_4) rx_byte_cnt <= _GEN_6 ? 4'h0 : _next_byte_cnt_T;
      end
      cmd_valid_reg <= ~_GEN_3 & _GEN_7;
      if (_GEN_8) begin
      end else begin
        cmd_addr_reg  <= {rx_buffer_4, rx_buffer_3, rx_buffer_2, rx_buffer_1};
        cmd_wdata_reg <= {_uart_rx_UART_RX_channel_bits, rx_buffer_7, rx_buffer_6, rx_buffer_5};
      end
      if (_GEN_0) begin
        if (UART_CMD_resp_valid) begin
          tx_state <= 2'h1;
          tx_byte_cnt <= 3'h0;
        end
      end else begin
        automatic logic _GEN_10;
        _GEN_10 = {1'h0, tx_byte_cnt} == tx_total_bytes - 4'h1;
        if (_GEN_1 & _uart_tx_UART_TX_channel_ready & _GEN_10) tx_state <= 2'h0;
        if (_GEN_1 & _uart_tx_UART_TX_channel_ready)
          tx_byte_cnt <= _GEN_10 ? 3'h0 : tx_byte_cnt + 3'h1;
      end
      if (_GEN_9) tx_total_bytes <= 4'h5;
    end
    if ((_GEN_3 | _GEN_5 & rx_byte_cnt == 4'h0) & _GEN_4)
      rx_buffer_0 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h1)) begin
    end else rx_buffer_1 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h2)) begin
    end else rx_buffer_2 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h3)) begin
    end else rx_buffer_3 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h4)) begin
    end else rx_buffer_4 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h5)) begin
    end else rx_buffer_5 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h6)) begin
    end else rx_buffer_6 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_3 | ~(_GEN_5 & _GEN_4 & rx_byte_cnt == 4'h7)) begin
    end else rx_buffer_7 <= _uart_rx_UART_RX_channel_bits;
    if (_GEN_8) begin
    end else cmd_type_reg <= rx_buffer_0 == 8'h2 ? 2'h2 : {1'h0, rx_buffer_0 == 8'h1};
    if (_GEN_9) begin
      tx_buffer_1 <= UART_CMD_resp_rdata[7:0];
      tx_buffer_2 <= UART_CMD_resp_rdata[15:8];
      tx_buffer_3 <= UART_CMD_resp_rdata[23:16];
      tx_buffer_4 <= UART_CMD_resp_rdata[31:24];
    end
  end  // always @(posedge)
  uart_tx_b115200_f100000000 uart_tx (
      .clock                (clock),
      .reset                (reset),
      .UART_TX_txd          (UART_CMD_txd),
      .UART_TX_channel_ready(_uart_tx_UART_TX_channel_ready),
      .UART_TX_channel_valid(~_GEN_0 & _GEN_1),
      .UART_TX_channel_bits (_GEN_0 | ~_GEN_1 ? 8'h0 : _GEN_2[tx_byte_cnt])
  );
  uart_rx_b115200_f100000000 uart_rx (
      .clock                (clock),
      .reset                (reset),
      .UART_RX_rxd          (UART_CMD_rxd),
      .UART_RX_channel_valid(_uart_rx_UART_RX_channel_valid),
      .UART_RX_channel_bits (_uart_rx_UART_RX_channel_bits),
      .UART_RX_error        (_uart_rx_UART_RX_error)
  );
  assign UART_CMD_cmd_valid = cmd_valid_reg;
  assign UART_CMD_cmd_type  = cmd_type_reg;
  assign UART_CMD_cmd_addr  = cmd_addr_reg;
  assign UART_CMD_cmd_wdata = cmd_wdata_reg;
endmodule

module axilite_master_uart_cmd_32x32_b115200_f100000000 (
    input         clock,
    reset,
    output [31:0] M_AXI_AWADDR,
    output        M_AXI_AWVALID,
    input         M_AXI_AWREADY,
    output [31:0] M_AXI_WDATA,
    output        M_AXI_WVALID,
    input         M_AXI_WREADY,
    M_AXI_BVALID,
    output        M_AXI_BREADY,
    output [31:0] M_AXI_ARADDR,
    output        M_AXI_ARVALID,
    input         M_AXI_ARREADY,
    input  [31:0] M_AXI_RDATA,
    input         M_AXI_RVALID,
    output        M_AXI_RREADY,
    TX,
    input         RX
);

  wire        _uart_cmd_UART_CMD_cmd_valid;
  wire [ 1:0] _uart_cmd_UART_CMD_cmd_type;
  wire [31:0] _uart_cmd_UART_CMD_cmd_addr;
  wire [31:0] _uart_cmd_UART_CMD_cmd_wdata;
  reg  [ 3:0] state;
  reg  [31:0] axi_awaddr;
  reg         axi_awvalid;
  reg  [31:0] axi_wdata;
  reg         axi_wvalid;
  reg         axi_bready;
  reg  [31:0] axi_araddr;
  reg         axi_arvalid;
  reg         axi_rready;
  reg         aw_done;
  reg         w_done;
  reg  [31:0] move_dst_addr;
  reg  [31:0] move_data_buf;
  wire        _GEN = state == 4'h0;
  wire        _GEN_0 = state == 4'h1;
  wire        _GEN_1 = state == 4'h3;
  wire        _GEN_2 = M_AXI_BVALID & axi_bready;
  wire        _GEN_3 = state == 4'h4;
  wire        _GEN_4 = state == 4'h5;
  wire        _GEN_5 = M_AXI_RVALID & axi_rready;
  wire        _GEN_6 = state == 4'h6;
  wire        _GEN_7 = state == 4'h7;
  wire        _GEN_8 = state == 4'h8;
  wire        _GEN_9 = state == 4'h9;
  wire        _GEN_10 = _GEN_9 & _GEN_2;
  wire        _GEN_11 = _GEN_6 | _GEN_7 | _GEN_8;
  always @(posedge clock) begin
    if (reset) begin
      state <= 4'h0;
      axi_awaddr <= 32'h0;
      axi_awvalid <= 1'h0;
      axi_wdata <= 32'h0;
      axi_wvalid <= 1'h0;
      axi_bready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arvalid <= 1'h0;
      axi_rready <= 1'h0;
      aw_done <= 1'h0;
      w_done <= 1'h0;
      move_dst_addr <= 32'h0;
      move_data_buf <= 32'h0;
    end else begin
      automatic logic _GEN_12;
      automatic logic _GEN_13;
      automatic logic _GEN_14;
      automatic logic _GEN_15 = _GEN & _uart_cmd_UART_CMD_cmd_valid;
      automatic logic _GEN_16;
      automatic logic _GEN_17;
      automatic logic _GEN_18;
      automatic logic _GEN_19;
      automatic logic _GEN_20;
      _GEN_12 = _uart_cmd_UART_CMD_cmd_type == 2'h0;
      _GEN_13 = _uart_cmd_UART_CMD_cmd_type == 2'h1;
      _GEN_14 = _uart_cmd_UART_CMD_cmd_type == 2'h2;
      _GEN_16 = M_AXI_ARREADY & axi_arvalid;
      _GEN_17 = _GEN_0 | _GEN_1;
      _GEN_18 = _GEN_7 & _GEN_5;
      _GEN_19 = _GEN_1 | _GEN_3 | _GEN_4 | _GEN_6;
      _GEN_20 = _GEN_0 | _GEN_19;
      if (_GEN) begin
        automatic logic _GEN_21;
        _GEN_21 = _uart_cmd_UART_CMD_cmd_valid & _GEN_12;
        if (_uart_cmd_UART_CMD_cmd_valid) begin
          automatic logic [3:0][3:0] _GEN_22 = {{state}, {4'h6}, {4'h4}, {4'h1}};
          state <= _GEN_22[_uart_cmd_UART_CMD_cmd_type];
        end
        if (_GEN_21) begin
          axi_awaddr <= _uart_cmd_UART_CMD_cmd_addr;
          axi_wdata  <= _uart_cmd_UART_CMD_cmd_wdata;
        end
        axi_awvalid <= _GEN_21 | axi_awvalid;
        axi_wvalid <= _GEN_21 | axi_wvalid;
        axi_arvalid <= _uart_cmd_UART_CMD_cmd_valid & ~_GEN_12 & (_GEN_13 | _GEN_14) | axi_arvalid;
        aw_done <= ~_GEN_21 & aw_done;
        w_done <= ~_GEN_21 & w_done;
      end else begin
        automatic logic _GEN_23;
        automatic logic _GEN_24;
        automatic logic _GEN_25;
        automatic logic _GEN_26;
        _GEN_23 = M_AXI_AWREADY & axi_awvalid;
        _GEN_24 = M_AXI_WREADY & axi_wvalid;
        _GEN_25 = aw_done & w_done;
        _GEN_26 = _GEN_25 | axi_bready;
        if (_GEN_0) begin
          if (_GEN_25) state <= 4'h3;
          axi_awvalid <= ~_GEN_23 & axi_awvalid;
          axi_wvalid <= ~_GEN_24 & axi_wvalid;
          axi_bready <= _GEN_26;
          aw_done <= _GEN_23 | aw_done;
          w_done <= _GEN_24 | w_done;
        end else begin
          if (_GEN_1) begin
            if (_GEN_2) state <= 4'h0;
            axi_bready <= ~_GEN_2 & axi_bready;
          end else begin
            if (_GEN_3) begin
              if (_GEN_16) state <= 4'h5;
            end else if (_GEN_4) begin
              if (_GEN_5) state <= 4'h0;
            end else if (_GEN_6) begin
              if (_GEN_16) state <= 4'h7;
            end else if (_GEN_7) begin
              if (_GEN_5) state <= 4'h8;
            end else if (_GEN_8) begin
              if (_GEN_25) state <= 4'h9;
            end else if (_GEN_10) state <= 4'h0;
            if (~(_GEN_3 | _GEN_4 | _GEN_6 | _GEN_7))
              axi_bready <= _GEN_8 ? _GEN_26 : ~_GEN_10 & axi_bready;
          end
          if (~_GEN_19) begin
            automatic logic _GEN_27;
            automatic logic _GEN_28;
            _GEN_27 = _GEN_8 & _GEN_23;
            _GEN_28 = _GEN_8 & _GEN_24;
            axi_awvalid <= _GEN_7 ? _GEN_5 | axi_awvalid : ~_GEN_27 & axi_awvalid;
            axi_wvalid <= _GEN_7 ? _GEN_5 | axi_wvalid : ~_GEN_28 & axi_wvalid;
            aw_done <= _GEN_7 ? ~_GEN_5 & aw_done : _GEN_27 | aw_done;
            w_done <= _GEN_7 ? ~_GEN_5 & w_done : _GEN_28 | w_done;
          end
        end
        if (_GEN_20 | ~_GEN_18) begin
        end else begin
          axi_awaddr <= move_dst_addr;
          axi_wdata  <= M_AXI_RDATA;
        end
        if (~_GEN_17)
          axi_arvalid <=
            _GEN_3
              ? ~_GEN_16 & axi_arvalid
              : (_GEN_4 | ~(_GEN_6 & _GEN_16)) & axi_arvalid;
      end
      if (_GEN_15) begin
        automatic
        logic [3:0][31:0]
        _GEN_29 = {
          {axi_araddr}, {_uart_cmd_UART_CMD_cmd_addr}, {_uart_cmd_UART_CMD_cmd_addr}, {axi_araddr}
        };
        axi_araddr <= _GEN_29[_uart_cmd_UART_CMD_cmd_type];
      end
      if (~(_GEN | _GEN_17)) begin
        automatic logic _GEN_30;
        _GEN_30 = _GEN_16 | axi_rready;
        axi_rready <=
          _GEN_3
            ? _GEN_30
            : _GEN_4 ? ~_GEN_5 & axi_rready : _GEN_6 ? _GEN_30 : ~_GEN_18 & axi_rready;
      end
      if (~_GEN_15 | _GEN_12 | _GEN_13 | ~_GEN_14) begin
      end else move_dst_addr <= _uart_cmd_UART_CMD_cmd_wdata;
      if (_GEN | _GEN_20 | ~_GEN_18) begin
      end else move_data_buf <= M_AXI_RDATA;
    end
  end  // always @(posedge)
  uart_level_b115200_f100000000 uart_cmd (
      .clock(clock),
      .reset(reset),
      .UART_CMD_txd(TX),
      .UART_CMD_rxd(RX),
      .UART_CMD_cmd_valid(_uart_cmd_UART_CMD_cmd_valid),
      .UART_CMD_cmd_type(_uart_cmd_UART_CMD_cmd_type),
      .UART_CMD_cmd_addr(_uart_cmd_UART_CMD_cmd_addr),
      .UART_CMD_cmd_wdata(_uart_cmd_UART_CMD_cmd_wdata),
      .UART_CMD_resp_valid
      (~(_GEN | _GEN_0)
       & (_GEN_1 ? _GEN_2 : ~_GEN_3 & (_GEN_4 ? _GEN_5 : ~_GEN_11 & _GEN_9 & _GEN_2))),
      .UART_CMD_resp_rdata
      (_GEN | _GEN_0 | _GEN_1 | _GEN_3
         ? 32'h0
         : _GEN_4
             ? (_GEN_5 ? M_AXI_RDATA : 32'h0)
             : _GEN_11 | ~_GEN_10 ? 32'h0 : move_data_buf)
  );
  assign M_AXI_AWADDR  = axi_awaddr;
  assign M_AXI_AWVALID = axi_awvalid;
  assign M_AXI_WDATA   = axi_wdata;
  assign M_AXI_WVALID  = axi_wvalid;
  assign M_AXI_BREADY  = axi_bready;
  assign M_AXI_ARADDR  = axi_araddr;
  assign M_AXI_ARVALID = axi_arvalid;
  assign M_AXI_RREADY  = axi_rready;
endmodule

module axi_lite2full_32x32_i4_u1 (
    output        S_AXI_aw_ready,
    input         S_AXI_aw_valid,
    input  [31:0] S_AXI_aw_bits_addr,
    output        S_AXI_w_ready,
    input         S_AXI_w_valid,
    input  [31:0] S_AXI_w_bits_data,
    input         S_AXI_b_ready,
    output        S_AXI_b_valid,
    S_AXI_ar_ready,
    input         S_AXI_ar_valid,
    input  [31:0] S_AXI_ar_bits_addr,
    input         S_AXI_r_ready,
    output        S_AXI_r_valid,
    output [31:0] S_AXI_r_bits_data,
    input         M_AXI_aw_ready,
    output        M_AXI_aw_valid,
    output [31:0] M_AXI_aw_bits_addr,
    input         M_AXI_w_ready,
    output        M_AXI_w_valid,
    output [31:0] M_AXI_w_bits_data,
    output        M_AXI_b_ready,
    input         M_AXI_b_valid,
    M_AXI_ar_ready,
    output        M_AXI_ar_valid,
    output [31:0] M_AXI_ar_bits_addr,
    output        M_AXI_r_ready,
    input         M_AXI_r_valid,
    input  [31:0] M_AXI_r_bits_data
);

  assign S_AXI_aw_ready = M_AXI_aw_ready;
  assign S_AXI_w_ready = M_AXI_w_ready;
  assign S_AXI_b_valid = M_AXI_b_valid;
  assign S_AXI_ar_ready = M_AXI_ar_ready;
  assign S_AXI_r_valid = M_AXI_r_valid;
  assign S_AXI_r_bits_data = M_AXI_r_bits_data;
  assign M_AXI_aw_valid = S_AXI_aw_valid;
  assign M_AXI_aw_bits_addr = S_AXI_aw_bits_addr;
  assign M_AXI_w_valid = S_AXI_w_valid;
  assign M_AXI_w_bits_data = S_AXI_w_bits_data;
  assign M_AXI_b_ready = S_AXI_b_ready;
  assign M_AXI_ar_valid = S_AXI_ar_valid;
  assign M_AXI_ar_bits_addr = S_AXI_ar_bits_addr;
  assign M_AXI_r_ready = S_AXI_r_ready;
endmodule

module axilite_interconnect2_32x32 (
    output        S_AXI_aw_ready,
    input         S_AXI_aw_valid,
    input  [31:0] S_AXI_aw_bits_addr,
    output        S_AXI_w_ready,
    input         S_AXI_w_valid,
    input  [31:0] S_AXI_w_bits_data,
    input         S_AXI_b_ready,
    output        S_AXI_b_valid,
    S_AXI_ar_ready,
    input         S_AXI_ar_valid,
    input  [31:0] S_AXI_ar_bits_addr,
    input         S_AXI_r_ready,
    output        S_AXI_r_valid,
    output [31:0] S_AXI_r_bits_data,
    input         M0_AXI_aw_ready,
    output        M0_AXI_aw_valid,
    output [31:0] M0_AXI_aw_bits_addr,
    input         M0_AXI_w_ready,
    output        M0_AXI_w_valid,
    output [31:0] M0_AXI_w_bits_data,
    output        M0_AXI_b_ready,
    input         M0_AXI_b_valid,
    M0_AXI_ar_ready,
    output        M0_AXI_ar_valid,
    output [31:0] M0_AXI_ar_bits_addr,
    output        M0_AXI_r_ready,
    input         M0_AXI_r_valid,
    input  [31:0] M0_AXI_r_bits_data,
    input         M1_AXI_aw_ready,
    output        M1_AXI_aw_valid,
    output [31:0] M1_AXI_aw_bits_addr,
    input         M1_AXI_w_ready,
    output        M1_AXI_w_valid,
    output [31:0] M1_AXI_w_bits_data,
    output        M1_AXI_b_ready,
    input         M1_AXI_b_valid,
    M1_AXI_ar_ready,
    output        M1_AXI_ar_valid,
    output [31:0] M1_AXI_ar_bits_addr,
    output        M1_AXI_r_ready,
    input         M1_AXI_r_valid,
    input  [31:0] M1_AXI_r_bits_data
);

  wire _S_AXI_b_bits_T_11 = S_AXI_aw_bits_addr < 32'h30000;
  wire _S_AXI_r_bits_T_11 = S_AXI_ar_bits_addr < 32'h30000;
  assign S_AXI_aw_ready =
    ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11) & M0_AXI_aw_ready
    | (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11 & M1_AXI_aw_ready;
  assign S_AXI_w_ready =
    ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11) & M0_AXI_w_ready
    | (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11 & M1_AXI_w_ready;
  assign S_AXI_b_valid =
    ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11) & M0_AXI_b_valid
    | (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11 & M1_AXI_b_valid;
  assign S_AXI_ar_ready =
    ~((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11) & M0_AXI_ar_ready
    | (|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11 & M1_AXI_ar_ready;
  assign S_AXI_r_valid =
    ~((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11) & M0_AXI_r_valid
    | (|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11 & M1_AXI_r_valid;
  assign S_AXI_r_bits_data =
    ((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11 ? 32'h0 : M0_AXI_r_bits_data)
    | ((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11 ? M1_AXI_r_bits_data : 32'h0);
  assign M0_AXI_aw_valid = S_AXI_aw_valid & ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11);
  assign M0_AXI_aw_bits_addr = S_AXI_aw_bits_addr;
  assign M0_AXI_w_valid = S_AXI_w_valid & ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11);
  assign M0_AXI_w_bits_data = S_AXI_w_bits_data;
  assign M0_AXI_b_ready = S_AXI_b_ready & ~((|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11);
  assign M0_AXI_ar_valid = S_AXI_ar_valid & ~((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11);
  assign M0_AXI_ar_bits_addr = S_AXI_ar_bits_addr;
  assign M0_AXI_r_ready = S_AXI_r_ready & ~((|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11);
  assign M1_AXI_aw_valid = S_AXI_aw_valid & (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11;
  assign M1_AXI_aw_bits_addr = S_AXI_aw_bits_addr;
  assign M1_AXI_w_valid = S_AXI_w_valid & (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11;
  assign M1_AXI_w_bits_data = S_AXI_w_bits_data;
  assign M1_AXI_b_ready = S_AXI_b_ready & (|(S_AXI_aw_bits_addr[31:17])) & _S_AXI_b_bits_T_11;
  assign M1_AXI_ar_valid = S_AXI_ar_valid & (|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11;
  assign M1_AXI_ar_bits_addr = S_AXI_ar_bits_addr;
  assign M1_AXI_r_ready = S_AXI_r_ready & (|(S_AXI_ar_bits_addr[31:17])) & _S_AXI_r_bits_T_11;
endmodule

module mmap_regs_32x32_r4 (
    input         clock,
    reset,
    MMAP_write_en,
    input  [31:0] MMAP_write_addr,
    MMAP_write_data,
    input         MMAP_read_en,
    input  [31:0] MMAP_read_addr,
    output [31:0] MMAP_read_data
);

  reg  [31:0] regs_0;
  reg  [31:0] regs_1;
  reg  [31:0] regs_2;
  reg  [31:0] regs_3;
  wire        _MMAP_read_data_T = MMAP_read_addr == 32'h10000;
  wire        _MMAP_read_data_T_1 = MMAP_read_addr == 32'h14000;
  wire        _MMAP_read_data_T_2 = MMAP_read_addr == 32'h18000;
  wire        _MMAP_read_data_T_3 = MMAP_read_addr == 32'h1C000;
  always @(posedge clock) begin
    if (reset) begin
      regs_0 <= 32'h0;
      regs_1 <= 32'h0;
      regs_2 <= 32'h0;
      regs_3 <= 32'h0;
    end else begin
      automatic logic _write_addr_match_T = MMAP_write_addr == 32'h10000;
      automatic logic _write_addr_match_T_1 = MMAP_write_addr == 32'h14000;
      automatic logic _write_addr_match_T_2 = MMAP_write_addr == 32'h18000;
      automatic logic _write_addr_match_T_3 = MMAP_write_addr == 32'h1C000;
      automatic
      logic
      _GEN =
        MMAP_write_en
        & (_write_addr_match_T | _write_addr_match_T_1 | _write_addr_match_T_2
           | _write_addr_match_T_3);
      if (_GEN & _write_addr_match_T) regs_0 <= MMAP_write_data;
      if (_GEN & _write_addr_match_T_1) regs_1 <= MMAP_write_data;
      if (_GEN & _write_addr_match_T_2) regs_2 <= MMAP_write_data;
      if (_GEN & _write_addr_match_T_3) regs_3 <= MMAP_write_data;
    end
  end  // always @(posedge)
  assign MMAP_read_data =
    MMAP_read_en
    & (_MMAP_read_data_T | _MMAP_read_data_T_1 | _MMAP_read_data_T_2
       | _MMAP_read_data_T_3)
      ? (_MMAP_read_data_T
           ? regs_0
           : _MMAP_read_data_T_1
               ? regs_1
               : _MMAP_read_data_T_2 ? regs_2 : _MMAP_read_data_T_3 ? regs_3 : 32'h0)
      : 32'h0;
endmodule

module axilite_slave_mmap_32x32_r4 (
    input         clock,
    reset,
    input  [31:0] S_AXI_AWADDR,
    input         S_AXI_AWVALID,
    output        S_AXI_AWREADY,
    input  [31:0] S_AXI_WDATA,
    input         S_AXI_WVALID,
    output        S_AXI_WREADY,
    S_AXI_BVALID,
    input         S_AXI_BREADY,
    input  [31:0] S_AXI_ARADDR,
    input         S_AXI_ARVALID,
    output        S_AXI_ARREADY,
    output [31:0] S_AXI_RDATA,
    output        S_AXI_RVALID,
    input         S_AXI_RREADY
);

  wire [31:0] _mmap_regs_MMAP_read_data;
  reg         axi_awready;
  reg  [31:0] axi_awaddr;
  reg         axi_wready;
  reg         axi_bvalid;
  reg         axi_arready;
  reg  [31:0] axi_araddr;
  reg  [31:0] axi_rdata;
  reg         axi_rvalid;
  always @(posedge clock) begin
    if (reset) begin
      axi_awready <= 1'h0;
      axi_awaddr  <= 32'h0;
      axi_wready  <= 1'h0;
      axi_bvalid  <= 1'h0;
      axi_arready <= 1'h0;
      axi_araddr  <= 32'h0;
      axi_rdata   <= 32'h0;
      axi_rvalid  <= 1'h0;
    end else begin
      automatic logic _GEN = ~axi_awready & S_AXI_AWVALID;
      automatic logic _GEN_0 = ~axi_arready & S_AXI_ARVALID;
      axi_awready <= _GEN;
      if (_GEN) axi_awaddr <= S_AXI_AWADDR;
      axi_wready <=
        ~axi_wready & axi_awready & S_AXI_AWVALID | ~(axi_wready & S_AXI_WVALID)
        & axi_wready;
      axi_bvalid <=
        ~axi_bvalid & axi_wready & S_AXI_WVALID | ~(S_AXI_BREADY & axi_bvalid)
        & axi_bvalid;
      axi_arready <= _GEN_0;
      if (_GEN_0) axi_araddr <= S_AXI_ARADDR;
      axi_rdata <= _mmap_regs_MMAP_read_data;
      axi_rvalid <=
        ~axi_rvalid & axi_arready & S_AXI_ARVALID | ~(axi_rvalid & S_AXI_RREADY)
        & axi_rvalid;
    end
  end  // always @(posedge)
  mmap_regs_32x32_r4 mmap_regs (
      .clock          (clock),
      .reset          (reset),
      .MMAP_write_en  (axi_awready & S_AXI_AWVALID & ~axi_bvalid),
      .MMAP_write_addr(axi_awaddr),
      .MMAP_write_data(S_AXI_WDATA),
      .MMAP_read_en   (axi_arready & S_AXI_ARVALID & ~axi_rvalid),
      .MMAP_read_addr (axi_araddr),
      .MMAP_read_data (_mmap_regs_MMAP_read_data)
  );
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY  = axi_wready;
  assign S_AXI_BVALID  = axi_bvalid;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA   = axi_rdata;
  assign S_AXI_RVALID  = axi_rvalid;
endmodule

module ram_32x32_s8_b131072 (
    input         clock,
    reset,
    RAM_write_en,
    input  [31:0] RAM_write_addr,
    RAM_write_data,
    input         RAM_read_en,
    input  [31:0] RAM_read_addr,
    output [31:0] RAM_read_data,
    output        RAM_read_resp
);

  reg [31:0] ram_0;
  reg [31:0] ram_1;
  reg [31:0] ram_2;
  reg [31:0] ram_3;
  reg [31:0] ram_4;
  reg [31:0] ram_5;
  reg [31:0] ram_6;
  reg [31:0] ram_7;
  wire [31:0] _aw_offset_addr_T = RAM_write_addr - 32'h20000;
  wire [31:0] _ar_offset_addr_T = RAM_read_addr - 32'h20000;
  wire ar_valid = (|(RAM_read_addr[31:17])) & _ar_offset_addr_T < 32'h20;
  wire [2:0]       _mem_addr_T_3 =
    RAM_read_en ? _ar_offset_addr_T[4:2] : RAM_write_en ? _aw_offset_addr_T[4:2] : 3'h0;
  wire [7:0][31:0] _GEN = {{ram_7}, {ram_6}, {ram_5}, {ram_4}, {ram_3}, {ram_2}, {ram_1}, {ram_0}};
  always @(posedge clock) begin
    if (reset) begin
      ram_0 <= 32'h0;
      ram_1 <= 32'h0;
      ram_2 <= 32'h0;
      ram_3 <= 32'h0;
      ram_4 <= 32'h0;
      ram_5 <= 32'h0;
      ram_6 <= 32'h0;
      ram_7 <= 32'h0;
    end else begin
      automatic
      logic
      _GEN_0 = RAM_write_en & (|(RAM_write_addr[31:17])) & _aw_offset_addr_T < 32'h20;
      if (_GEN_0 & _mem_addr_T_3 == 3'h0) ram_0 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h1) ram_1 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h2) ram_2 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h3) ram_3 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h4) ram_4 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h5) ram_5 <= RAM_write_data;
      if (_GEN_0 & _mem_addr_T_3 == 3'h6) ram_6 <= RAM_write_data;
      if (_GEN_0 & (&_mem_addr_T_3)) ram_7 <= RAM_write_data;
    end
  end  // always @(posedge)
  assign RAM_read_data = RAM_read_en & ar_valid ? _GEN[_mem_addr_T_3] : 32'h0;
  assign RAM_read_resp = ar_valid;
endmodule

module axifull_slave_ram_32x32_i4_u1_s8_b131072 (
    input         clock,
    reset,
    input  [31:0] S_AXI_AWADDR,
    input         S_AXI_AWVALID,
    output        S_AXI_AWREADY,
    input  [31:0] S_AXI_WDATA,
    input         S_AXI_WVALID,
    output        S_AXI_WREADY,
    input         S_AXI_BREADY,
    output        S_AXI_BVALID,
    input  [31:0] S_AXI_ARADDR,
    input         S_AXI_ARVALID,
    output        S_AXI_ARREADY,
    input         S_AXI_RREADY,
    output [31:0] S_AXI_RDATA,
    output        S_AXI_RVALID
);

  wire [31:0] _mmap_region_RAM_read_data;
  wire        _mmap_region_RAM_read_resp;
  reg         axi_awready;
  reg         axi_awv_awr_flag;
  reg  [31:0] axi_awaddr;
  reg  [ 1:0] axi_awburst;
  reg  [ 7:0] axi_awlen_cntr;
  reg         axi_wready;
  reg         axi_bvalid;
  reg         axi_arready;
  reg  [31:0] axi_araddr;
  reg  [ 1:0] axi_arburst;
  reg  [ 7:0] axi_arlen_cntr;
  reg         axi_arv_arr_flag;
  reg         axi_rvalid;
  always @(posedge clock) begin
    if (reset) begin
      axi_awready <= 1'h0;
      axi_awv_awr_flag <= 1'h0;
      axi_awaddr <= 32'h0;
      axi_awburst <= 2'h0;
      axi_awlen_cntr <= 8'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_arburst <= 2'h0;
      axi_arlen_cntr <= 8'h0;
      axi_arv_arr_flag <= 1'h0;
      axi_rvalid <= 1'h0;
    end else begin
      automatic logic _GEN = ~axi_awready & S_AXI_AWVALID & ~axi_awv_awr_flag;
      automatic logic _GEN_0 = _GEN & ~axi_arv_arr_flag;
      automatic logic _GEN_1 = ~axi_arready & S_AXI_ARVALID;
      automatic logic _GEN_2 = _GEN_1 & ~axi_awv_awr_flag & ~axi_arv_arr_flag;
      automatic logic _GEN_3 = axi_rvalid & S_AXI_RREADY;
      automatic logic _GEN_4;
      automatic logic _GEN_5;
      _GEN_4 = axi_arlen_cntr == 8'h0;
      _GEN_5 = _GEN_3 & _GEN_4;
      axi_awready <= _GEN_0 | axi_wready & axi_awready;
      axi_awv_awr_flag <= _GEN_0 | ~axi_wready & axi_awv_awr_flag;
      if (_GEN) begin
        axi_awaddr <= S_AXI_AWADDR;
        axi_awburst <= 2'h1;
        axi_awlen_cntr <= 8'h0;
      end else if (axi_awlen_cntr == 8'h0 & axi_wready & S_AXI_WVALID) begin
        automatic
        logic [3:0][31:0]
        _GEN_6 = {
          {{2'h0, axi_awaddr[31:2] + 30'h1}},
          {axi_awaddr},
          {{axi_awaddr[31:2] + 30'h1, 2'h0}},
          {axi_awaddr}
        };
        axi_awaddr <= _GEN_6[axi_awburst];
        axi_awlen_cntr <= axi_awlen_cntr + 8'h1;
      end
      axi_wready <= ~axi_wready & S_AXI_WVALID & axi_awv_awr_flag;
      axi_bvalid <=
        axi_awv_awr_flag & axi_wready & S_AXI_WVALID & ~axi_bvalid
        | ~(S_AXI_BREADY & axi_bvalid) & axi_bvalid;
      axi_arready <= _GEN_2 | _GEN_5 & axi_arready;
      if (_GEN_1 & ~axi_arv_arr_flag) begin
        axi_araddr <= S_AXI_ARADDR;
        axi_arburst <= 2'h1;
        axi_arlen_cntr <= 8'h0;
      end else if (_GEN_4 & axi_rvalid & S_AXI_RREADY) begin
        automatic
        logic [3:0][31:0]
        _GEN_7 = {
          {{2'h0, S_AXI_ARADDR[31:2] + 30'h1}},
          {axi_araddr},
          {{axi_araddr[31:2] + 30'h1, 2'h0}},
          {axi_araddr}
        };
        axi_araddr <= _GEN_7[axi_arburst];
        axi_arlen_cntr <= axi_arlen_cntr + 8'h1;
      end
      axi_arv_arr_flag <= _GEN_2 | ~_GEN_5 & axi_arv_arr_flag;
      axi_rvalid <= axi_arv_arr_flag & ~axi_rvalid | ~_GEN_3 & axi_rvalid;
    end
  end  // always @(posedge)
  ram_32x32_s8_b131072 mmap_region (
      .clock         (clock),
      .reset         (reset),
      .RAM_write_en  (axi_wready & S_AXI_WVALID),
      .RAM_write_addr(axi_awaddr),
      .RAM_write_data(S_AXI_WDATA),
      .RAM_read_en   (axi_arv_arr_flag),
      .RAM_read_addr (axi_araddr),
      .RAM_read_data (_mmap_region_RAM_read_data),
      .RAM_read_resp (_mmap_region_RAM_read_resp)
  );
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY = axi_wready;
  assign S_AXI_BVALID = axi_bvalid;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA = axi_rvalid & _mmap_region_RAM_read_resp ? _mmap_region_RAM_read_data : 32'h0;
  assign S_AXI_RVALID = axi_rvalid;
endmodule

module axi_cmd_test_module (
    input  clock,
    reset,
    output TXD,
    input  RXD
);

  wire        _slave2_S_AXI_AWREADY;
  wire        _slave2_S_AXI_WREADY;
  wire        _slave2_S_AXI_BVALID;
  wire        _slave2_S_AXI_ARREADY;
  wire [31:0] _slave2_S_AXI_RDATA;
  wire        _slave2_S_AXI_RVALID;
  wire        _slave1_S_AXI_AWREADY;
  wire        _slave1_S_AXI_WREADY;
  wire        _slave1_S_AXI_BVALID;
  wire        _slave1_S_AXI_ARREADY;
  wire [31:0] _slave1_S_AXI_RDATA;
  wire        _slave1_S_AXI_RVALID;
  wire        _interconnect_S_AXI_aw_ready;
  wire        _interconnect_S_AXI_w_ready;
  wire        _interconnect_S_AXI_b_valid;
  wire        _interconnect_S_AXI_ar_ready;
  wire        _interconnect_S_AXI_r_valid;
  wire [31:0] _interconnect_S_AXI_r_bits_data;
  wire        _interconnect_M0_AXI_aw_valid;
  wire [31:0] _interconnect_M0_AXI_aw_bits_addr;
  wire        _interconnect_M0_AXI_w_valid;
  wire [31:0] _interconnect_M0_AXI_w_bits_data;
  wire        _interconnect_M0_AXI_b_ready;
  wire        _interconnect_M0_AXI_ar_valid;
  wire [31:0] _interconnect_M0_AXI_ar_bits_addr;
  wire        _interconnect_M0_AXI_r_ready;
  wire        _interconnect_M1_AXI_aw_valid;
  wire [31:0] _interconnect_M1_AXI_aw_bits_addr;
  wire        _interconnect_M1_AXI_w_valid;
  wire [31:0] _interconnect_M1_AXI_w_bits_data;
  wire        _interconnect_M1_AXI_b_ready;
  wire        _interconnect_M1_AXI_ar_valid;
  wire [31:0] _interconnect_M1_AXI_ar_bits_addr;
  wire        _interconnect_M1_AXI_r_ready;
  wire        _lite2fullBridge_S_AXI_aw_ready;
  wire        _lite2fullBridge_S_AXI_w_ready;
  wire        _lite2fullBridge_S_AXI_b_valid;
  wire        _lite2fullBridge_S_AXI_ar_ready;
  wire        _lite2fullBridge_S_AXI_r_valid;
  wire [31:0] _lite2fullBridge_S_AXI_r_bits_data;
  wire        _lite2fullBridge_M_AXI_aw_valid;
  wire [31:0] _lite2fullBridge_M_AXI_aw_bits_addr;
  wire        _lite2fullBridge_M_AXI_w_valid;
  wire [31:0] _lite2fullBridge_M_AXI_w_bits_data;
  wire        _lite2fullBridge_M_AXI_b_ready;
  wire        _lite2fullBridge_M_AXI_ar_valid;
  wire [31:0] _lite2fullBridge_M_AXI_ar_bits_addr;
  wire        _lite2fullBridge_M_AXI_r_ready;
  wire [31:0] _master_M_AXI_AWADDR;
  wire        _master_M_AXI_AWVALID;
  wire [31:0] _master_M_AXI_WDATA;
  wire        _master_M_AXI_WVALID;
  wire        _master_M_AXI_BREADY;
  wire [31:0] _master_M_AXI_ARADDR;
  wire        _master_M_AXI_ARVALID;
  wire        _master_M_AXI_RREADY;
  axilite_master_uart_cmd_32x32_b115200_f100000000 master (
      .clock        (clock),
      .reset        (reset),
      .M_AXI_AWADDR (_master_M_AXI_AWADDR),
      .M_AXI_AWVALID(_master_M_AXI_AWVALID),
      .M_AXI_AWREADY(_interconnect_S_AXI_aw_ready),
      .M_AXI_WDATA  (_master_M_AXI_WDATA),
      .M_AXI_WVALID (_master_M_AXI_WVALID),
      .M_AXI_WREADY (_interconnect_S_AXI_w_ready),
      .M_AXI_BVALID (_interconnect_S_AXI_b_valid),
      .M_AXI_BREADY (_master_M_AXI_BREADY),
      .M_AXI_ARADDR (_master_M_AXI_ARADDR),
      .M_AXI_ARVALID(_master_M_AXI_ARVALID),
      .M_AXI_ARREADY(_interconnect_S_AXI_ar_ready),
      .M_AXI_RDATA  (_interconnect_S_AXI_r_bits_data),
      .M_AXI_RVALID (_interconnect_S_AXI_r_valid),
      .M_AXI_RREADY (_master_M_AXI_RREADY),
      .TX           (TXD),
      .RX           (RXD)
  );
  axi_lite2full_32x32_i4_u1 lite2fullBridge (
      .S_AXI_aw_ready    (_lite2fullBridge_S_AXI_aw_ready),
      .S_AXI_aw_valid    (_interconnect_M1_AXI_aw_valid),
      .S_AXI_aw_bits_addr(_interconnect_M1_AXI_aw_bits_addr),
      .S_AXI_w_ready     (_lite2fullBridge_S_AXI_w_ready),
      .S_AXI_w_valid     (_interconnect_M1_AXI_w_valid),
      .S_AXI_w_bits_data (_interconnect_M1_AXI_w_bits_data),
      .S_AXI_b_ready     (_interconnect_M1_AXI_b_ready),
      .S_AXI_b_valid     (_lite2fullBridge_S_AXI_b_valid),
      .S_AXI_ar_ready    (_lite2fullBridge_S_AXI_ar_ready),
      .S_AXI_ar_valid    (_interconnect_M1_AXI_ar_valid),
      .S_AXI_ar_bits_addr(_interconnect_M1_AXI_ar_bits_addr),
      .S_AXI_r_ready     (_interconnect_M1_AXI_r_ready),
      .S_AXI_r_valid     (_lite2fullBridge_S_AXI_r_valid),
      .S_AXI_r_bits_data (_lite2fullBridge_S_AXI_r_bits_data),
      .M_AXI_aw_ready    (_slave2_S_AXI_AWREADY),
      .M_AXI_aw_valid    (_lite2fullBridge_M_AXI_aw_valid),
      .M_AXI_aw_bits_addr(_lite2fullBridge_M_AXI_aw_bits_addr),
      .M_AXI_w_ready     (_slave2_S_AXI_WREADY),
      .M_AXI_w_valid     (_lite2fullBridge_M_AXI_w_valid),
      .M_AXI_w_bits_data (_lite2fullBridge_M_AXI_w_bits_data),
      .M_AXI_b_ready     (_lite2fullBridge_M_AXI_b_ready),
      .M_AXI_b_valid     (_slave2_S_AXI_BVALID),
      .M_AXI_ar_ready    (_slave2_S_AXI_ARREADY),
      .M_AXI_ar_valid    (_lite2fullBridge_M_AXI_ar_valid),
      .M_AXI_ar_bits_addr(_lite2fullBridge_M_AXI_ar_bits_addr),
      .M_AXI_r_ready     (_lite2fullBridge_M_AXI_r_ready),
      .M_AXI_r_valid     (_slave2_S_AXI_RVALID),
      .M_AXI_r_bits_data (_slave2_S_AXI_RDATA)
  );
  axilite_interconnect2_32x32 interconnect_0 (
      .S_AXI_aw_ready     (_interconnect_S_AXI_aw_ready),
      .S_AXI_aw_valid     (_master_M_AXI_AWVALID),
      .S_AXI_aw_bits_addr (_master_M_AXI_AWADDR),
      .S_AXI_w_ready      (_interconnect_S_AXI_w_ready),
      .S_AXI_w_valid      (_master_M_AXI_WVALID),
      .S_AXI_w_bits_data  (_master_M_AXI_WDATA),
      .S_AXI_b_ready      (_master_M_AXI_BREADY),
      .S_AXI_b_valid      (_interconnect_S_AXI_b_valid),
      .S_AXI_ar_ready     (_interconnect_S_AXI_ar_ready),
      .S_AXI_ar_valid     (_master_M_AXI_ARVALID),
      .S_AXI_ar_bits_addr (_master_M_AXI_ARADDR),
      .S_AXI_r_ready      (_master_M_AXI_RREADY),
      .S_AXI_r_valid      (_interconnect_S_AXI_r_valid),
      .S_AXI_r_bits_data  (_interconnect_S_AXI_r_bits_data),
      .M0_AXI_aw_ready    (_slave1_S_AXI_AWREADY),
      .M0_AXI_aw_valid    (_interconnect_M0_AXI_aw_valid),
      .M0_AXI_aw_bits_addr(_interconnect_M0_AXI_aw_bits_addr),
      .M0_AXI_w_ready     (_slave1_S_AXI_WREADY),
      .M0_AXI_w_valid     (_interconnect_M0_AXI_w_valid),
      .M0_AXI_w_bits_data (_interconnect_M0_AXI_w_bits_data),
      .M0_AXI_b_ready     (_interconnect_M0_AXI_b_ready),
      .M0_AXI_b_valid     (_slave1_S_AXI_BVALID),
      .M0_AXI_ar_ready    (_slave1_S_AXI_ARREADY),
      .M0_AXI_ar_valid    (_interconnect_M0_AXI_ar_valid),
      .M0_AXI_ar_bits_addr(_interconnect_M0_AXI_ar_bits_addr),
      .M0_AXI_r_ready     (_interconnect_M0_AXI_r_ready),
      .M0_AXI_r_valid     (_slave1_S_AXI_RVALID),
      .M0_AXI_r_bits_data (_slave1_S_AXI_RDATA),
      .M1_AXI_aw_ready    (_lite2fullBridge_S_AXI_aw_ready),
      .M1_AXI_aw_valid    (_interconnect_M1_AXI_aw_valid),
      .M1_AXI_aw_bits_addr(_interconnect_M1_AXI_aw_bits_addr),
      .M1_AXI_w_ready     (_lite2fullBridge_S_AXI_w_ready),
      .M1_AXI_w_valid     (_interconnect_M1_AXI_w_valid),
      .M1_AXI_w_bits_data (_interconnect_M1_AXI_w_bits_data),
      .M1_AXI_b_ready     (_interconnect_M1_AXI_b_ready),
      .M1_AXI_b_valid     (_lite2fullBridge_S_AXI_b_valid),
      .M1_AXI_ar_ready    (_lite2fullBridge_S_AXI_ar_ready),
      .M1_AXI_ar_valid    (_interconnect_M1_AXI_ar_valid),
      .M1_AXI_ar_bits_addr(_interconnect_M1_AXI_ar_bits_addr),
      .M1_AXI_r_ready     (_interconnect_M1_AXI_r_ready),
      .M1_AXI_r_valid     (_lite2fullBridge_S_AXI_r_valid),
      .M1_AXI_r_bits_data (_lite2fullBridge_S_AXI_r_bits_data)
  );
  axilite_slave_mmap_32x32_r4 slave1 (
      .clock        (clock),
      .reset        (reset),
      .S_AXI_AWADDR (_interconnect_M0_AXI_aw_bits_addr),
      .S_AXI_AWVALID(_interconnect_M0_AXI_aw_valid),
      .S_AXI_AWREADY(_slave1_S_AXI_AWREADY),
      .S_AXI_WDATA  (_interconnect_M0_AXI_w_bits_data),
      .S_AXI_WVALID (_interconnect_M0_AXI_w_valid),
      .S_AXI_WREADY (_slave1_S_AXI_WREADY),
      .S_AXI_BVALID (_slave1_S_AXI_BVALID),
      .S_AXI_BREADY (_interconnect_M0_AXI_b_ready),
      .S_AXI_ARADDR (_interconnect_M0_AXI_ar_bits_addr),
      .S_AXI_ARVALID(_interconnect_M0_AXI_ar_valid),
      .S_AXI_ARREADY(_slave1_S_AXI_ARREADY),
      .S_AXI_RDATA  (_slave1_S_AXI_RDATA),
      .S_AXI_RVALID (_slave1_S_AXI_RVALID),
      .S_AXI_RREADY (_interconnect_M0_AXI_r_ready)
  );
  axifull_slave_ram_32x32_i4_u1_s8_b131072 slave2 (
      .clock        (clock),
      .reset        (reset),
      .S_AXI_AWADDR (_lite2fullBridge_M_AXI_aw_bits_addr),
      .S_AXI_AWVALID(_lite2fullBridge_M_AXI_aw_valid),
      .S_AXI_AWREADY(_slave2_S_AXI_AWREADY),
      .S_AXI_WDATA  (_lite2fullBridge_M_AXI_w_bits_data),
      .S_AXI_WVALID (_lite2fullBridge_M_AXI_w_valid),
      .S_AXI_WREADY (_slave2_S_AXI_WREADY),
      .S_AXI_BREADY (_lite2fullBridge_M_AXI_b_ready),
      .S_AXI_BVALID (_slave2_S_AXI_BVALID),
      .S_AXI_ARADDR (_lite2fullBridge_M_AXI_ar_bits_addr),
      .S_AXI_ARVALID(_lite2fullBridge_M_AXI_ar_valid),
      .S_AXI_ARREADY(_slave2_S_AXI_ARREADY),
      .S_AXI_RREADY (_lite2fullBridge_M_AXI_r_ready),
      .S_AXI_RDATA  (_slave2_S_AXI_RDATA),
      .S_AXI_RVALID (_slave2_S_AXI_RVALID)
  );
endmodule
