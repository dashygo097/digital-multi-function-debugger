`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module mmap_regs_32x32_r4(
  input         clock,
                reset,
                MMAP_write_en,
  input  [31:0] MMAP_write_addr,
                MMAP_write_data,
  input  [3:0]  MMAP_write_strb,
  input         MMAP_read_en,
  input  [31:0] MMAP_read_addr,
  output [31:0] MMAP_read_data,
  output        MMAP_read_resp
);

  reg  [31:0] regs_0;
  reg  [31:0] regs_1;
  reg  [31:0] regs_2;
  reg  [31:0] regs_3;
  wire        read_addr_match =
    MMAP_read_addr == 32'h10000 | MMAP_read_addr == 32'h14000
    | MMAP_read_addr == 32'h18000 | MMAP_read_addr == 32'h1C000;
  always @(posedge clock) begin
    if (reset) begin
      regs_0 <= 32'h0;
      regs_1 <= 32'h0;
      regs_2 <= 32'h0;
      regs_3 <= 32'h0;
    end
    else begin
      automatic logic _GEN =
        MMAP_write_en
        & (MMAP_write_addr == 32'h10000 | MMAP_write_addr == 32'h14000
           | MMAP_write_addr == 32'h18000 | MMAP_write_addr == 32'h1C000);
      if (_GEN & MMAP_write_addr == 32'h10000)
        regs_0 <=
          {MMAP_write_strb[3] ? MMAP_write_data[31:24] : regs_0[31:24],
           MMAP_write_strb[2] ? MMAP_write_data[23:16] : regs_0[23:16],
           MMAP_write_strb[1] ? MMAP_write_data[15:8] : regs_0[15:8],
           MMAP_write_strb[0] ? MMAP_write_data[7:0] : regs_0[7:0]};
      if (_GEN & MMAP_write_addr == 32'h14000)
        regs_1 <=
          {MMAP_write_strb[3] ? MMAP_write_data[31:24] : regs_1[31:24],
           MMAP_write_strb[2] ? MMAP_write_data[23:16] : regs_1[23:16],
           MMAP_write_strb[1] ? MMAP_write_data[15:8] : regs_1[15:8],
           MMAP_write_strb[0] ? MMAP_write_data[7:0] : regs_1[7:0]};
      if (_GEN & MMAP_write_addr == 32'h18000)
        regs_2 <=
          {MMAP_write_strb[3] ? MMAP_write_data[31:24] : regs_2[31:24],
           MMAP_write_strb[2] ? MMAP_write_data[23:16] : regs_2[23:16],
           MMAP_write_strb[1] ? MMAP_write_data[15:8] : regs_2[15:8],
           MMAP_write_strb[0] ? MMAP_write_data[7:0] : regs_2[7:0]};
      if (_GEN & MMAP_write_addr == 32'h1C000)
        regs_3 <=
          {MMAP_write_strb[3] ? MMAP_write_data[31:24] : regs_3[31:24],
           MMAP_write_strb[2] ? MMAP_write_data[23:16] : regs_3[23:16],
           MMAP_write_strb[1] ? MMAP_write_data[15:8] : regs_3[15:8],
           MMAP_write_strb[0] ? MMAP_write_data[7:0] : regs_3[7:0]};
    end
  end // always @(posedge)
  assign MMAP_read_data =
    MMAP_read_en & read_addr_match
      ? (MMAP_read_addr == 32'h10000
           ? regs_0
           : MMAP_read_addr == 32'h14000
               ? regs_1
               : MMAP_read_addr == 32'h18000
                   ? regs_2
                   : MMAP_read_addr == 32'h1C000 ? regs_3 : 32'h0)
      : 32'h0;
  assign MMAP_read_resp = read_addr_match;
endmodule

module axilite_slave_mmap_32x32_r4(
  input         clock,
                reset,
  input  [31:0] S_AXI_AWADDR,
  input  [2:0]  S_AXI_AWPROT,
  input         S_AXI_AWVALID,
  output        S_AXI_AWREADY,
  input  [31:0] S_AXI_WDATA,
  input  [3:0]  S_AXI_WSTRB,
  input         S_AXI_WVALID,
  output        S_AXI_WREADY,
  output [1:0]  S_AXI_BRESP,
  output        S_AXI_BVALID,
  input         S_AXI_BREADY,
  input  [31:0] S_AXI_ARADDR,
  input  [2:0]  S_AXI_ARPROT,
  input         S_AXI_ARVALID,
  output        S_AXI_ARREADY,
  output [31:0] S_AXI_RDATA,
  output [1:0]  S_AXI_RRESP,
  output        S_AXI_RVALID,
  input         S_AXI_RREADY
);

  wire [31:0] _mmap_regs_MMAP_read_data;
  wire        _mmap_regs_MMAP_read_resp;
  reg         aw_en;
  reg         axi_awready;
  reg  [31:0] axi_awaddr;
  reg         axi_wready;
  reg         axi_bvalid;
  reg  [1:0]  axi_bresp;
  reg         axi_arready;
  reg  [31:0] axi_araddr;
  reg  [31:0] axi_rdata;
  reg         axi_rvalid;
  reg  [1:0]  axi_rresp;
  wire        _slv_reg_re_T = axi_arready & S_AXI_ARVALID;
  always @(posedge clock) begin
    if (reset) begin
      aw_en <= 1'h1;
      axi_awready <= 1'h0;
      axi_awaddr <= 32'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_bresp <= 2'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_rdata <= 32'h0;
      axi_rvalid <= 1'h0;
      axi_rresp <= 2'h0;
    end
    else begin
      automatic logic _GEN = ~axi_awready & S_AXI_AWVALID & S_AXI_WVALID & aw_en;
      automatic logic _GEN_0 = S_AXI_BREADY & axi_bvalid;
      automatic logic _GEN_1 =
        axi_awready & S_AXI_AWVALID & ~axi_bvalid & axi_wready & S_AXI_WVALID;
      automatic logic _GEN_2 = ~axi_arready & S_AXI_ARVALID;
      automatic logic _GEN_3 = _slv_reg_re_T & ~axi_rvalid;
      aw_en <= ~_GEN & (_GEN_0 | aw_en);
      axi_awready <= _GEN;
      if (_GEN)
        axi_awaddr <= S_AXI_AWADDR;
      axi_wready <= ~axi_wready & S_AXI_WVALID & S_AXI_AWVALID & aw_en;
      axi_bvalid <= _GEN_1 | ~_GEN_0 & axi_bvalid;
      if (_GEN_1)
        axi_bresp <= {~_mmap_regs_MMAP_read_resp, 1'h0};
      axi_arready <= _GEN_2;
      if (_GEN_2)
        axi_araddr <= S_AXI_ARADDR;
      axi_rdata <= _mmap_regs_MMAP_read_data;
      axi_rvalid <= _GEN_3 | ~(axi_rvalid & S_AXI_RREADY) & axi_rvalid;
      if (_GEN_3)
        axi_rresp <= {~_mmap_regs_MMAP_read_resp, 1'h0};
    end
  end // always @(posedge)
  mmap_regs_32x32_r4 mmap_regs (
    .clock           (clock),
    .reset           (reset),
    .MMAP_write_en   (axi_wready & S_AXI_WVALID & axi_awready & S_AXI_AWVALID),
    .MMAP_write_addr (axi_awaddr),
    .MMAP_write_data (S_AXI_WDATA),
    .MMAP_write_strb (S_AXI_WSTRB),
    .MMAP_read_en    (_slv_reg_re_T & ~axi_rvalid),
    .MMAP_read_addr  (axi_araddr),
    .MMAP_read_data  (_mmap_regs_MMAP_read_data),
    .MMAP_read_resp  (_mmap_regs_MMAP_read_resp)
  );
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY = axi_wready;
  assign S_AXI_BRESP = axi_bresp;
  assign S_AXI_BVALID = axi_bvalid;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA = axi_rdata;
  assign S_AXI_RRESP = axi_rresp;
  assign S_AXI_RVALID = axi_rvalid;
endmodule

