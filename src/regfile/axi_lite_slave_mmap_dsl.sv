`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module axilite_slave_mmap_4x32x32_r4 (
    input         clock,
    reset,
    input  [31:0] S_AXI_AWADDR,
    input  [ 2:0] S_AXI_AWPROT,
    input         S_AXI_AWVALID,
    output        S_AXI_AWREADY,
    input  [31:0] S_AXI_WDATA,
    input  [ 3:0] S_AXI_WSTRB,
    input         S_AXI_WVALID,
    output        S_AXI_WREADY,
    output [ 1:0] S_AXI_BRESP,
    output        S_AXI_BVALID,
    input         S_AXI_BREADY,
    input  [31:0] S_AXI_ARADDR,
    input  [ 2:0] S_AXI_ARPROT,
    input         S_AXI_ARVALID,
    output        S_AXI_ARREADY,
    output [31:0] S_AXI_RDATA,
    output [ 1:0] S_AXI_RRESP,
    output        S_AXI_RVALID,
    input         S_AXI_RREADY
);

  reg        aw_en;
  reg        axi_awready;
  reg [31:0] axi_awaddr;
  reg        axi_wready;
  reg        axi_bvalid;
  reg [ 1:0] axi_bresp;
  reg        axi_arready;
  reg [31:0] axi_araddr;
  reg [31:0] axi_rdata;
  reg        axi_rvalid;
  reg [ 1:0] axi_rresp;
  reg        write_addr_error;
  reg        read_addr_error;
  reg [31:0] slv_reg0;
  reg [31:0] slv_reg1;
  reg [31:0] slv_reg2;
  reg [31:0] slv_reg3;
  always @(posedge clock) begin
    if (reset) begin
      aw_en <= 1'h1;
      axi_awready <= 1'h0;
      axi_awaddr <= 32'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_bresp <= 2'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 32'h0;
      axi_rdata <= 32'h0;
      axi_rvalid <= 1'h0;
      axi_rresp <= 2'h0;
      write_addr_error <= 1'h0;
      read_addr_error <= 1'h0;
      slv_reg0 <= 32'h0;
      slv_reg1 <= 32'h0;
      slv_reg2 <= 32'h0;
      slv_reg3 <= 32'h0;
    end else begin
      automatic logic _write_addr_match_T = axi_awaddr == 32'h10000;
      automatic logic _write_addr_match_T_1 = axi_awaddr == 32'h14000;
      automatic logic _write_addr_match_T_2 = axi_awaddr == 32'h18000;
      automatic logic _write_addr_match_T_3 = axi_awaddr == 32'h1C000;
      automatic logic write_addr_match;
      automatic logic _axi_rdata_T;
      automatic logic _axi_rdata_T_1;
      automatic logic _axi_rdata_T_2;
      automatic logic _axi_rdata_T_3;
      automatic logic read_addr_match;
      automatic logic _slv_reg_re_T = axi_arready & S_AXI_ARVALID;
      automatic logic _GEN = ~axi_awready & S_AXI_AWVALID & S_AXI_WVALID & aw_en;
      automatic logic _GEN_0;
      automatic
      logic
      _GEN_1 = axi_awready & S_AXI_AWVALID & ~axi_bvalid & axi_wready & S_AXI_WVALID;
      automatic logic _GEN_2 = ~axi_arready & S_AXI_ARVALID;
      automatic logic _GEN_3 = _slv_reg_re_T & ~axi_rvalid;
      automatic logic _GEN_4;
      write_addr_match =
        _write_addr_match_T | _write_addr_match_T_1 | _write_addr_match_T_2
        | _write_addr_match_T_3;
      _axi_rdata_T = axi_araddr == 32'h10000;
      _axi_rdata_T_1 = axi_araddr == 32'h14000;
      _axi_rdata_T_2 = axi_araddr == 32'h18000;
      _axi_rdata_T_3 = axi_araddr == 32'h1C000;
      read_addr_match = _axi_rdata_T | _axi_rdata_T_1 | _axi_rdata_T_2 | _axi_rdata_T_3;
      _GEN_0 = S_AXI_BREADY & axi_bvalid;
      _GEN_4 = axi_wready & S_AXI_WVALID & axi_awready & S_AXI_AWVALID & write_addr_match;
      aw_en <= ~_GEN & (_GEN_0 | aw_en);
      axi_awready <= _GEN;
      if (_GEN) begin
        axi_awaddr <= S_AXI_AWADDR;
        write_addr_error <= ~write_addr_match;
      end else write_addr_error <= ~_GEN_0 & write_addr_error;
      axi_wready <= ~axi_wready & S_AXI_WVALID & S_AXI_AWVALID & aw_en;
      axi_bvalid <= _GEN_1 | ~_GEN_0 & axi_bvalid;
      if (_GEN_1) axi_bresp <= {write_addr_error, 1'h0};
      axi_arready <= _GEN_2;
      if (_GEN_2) axi_araddr <= S_AXI_ARADDR;
      if (_slv_reg_re_T & ~axi_rvalid)
        axi_rdata <=
          read_addr_match
            ? (_axi_rdata_T
                 ? slv_reg0
                 : _axi_rdata_T_1
                     ? slv_reg1
                     : _axi_rdata_T_2 ? slv_reg2 : _axi_rdata_T_3 ? slv_reg3 : 32'h0)
            : 32'h0;
      axi_rvalid <= _GEN_3 | ~(axi_rvalid & S_AXI_RREADY) & axi_rvalid;
      if (_GEN_3) axi_rresp <= {read_addr_error, 1'h0};
      read_addr_error <= _GEN_2 & ~read_addr_match;
      if (_GEN_4 & _write_addr_match_T)
        slv_reg0 <= {
          S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg0[31:24],
          S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg0[23:16],
          S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg0[15:8],
          S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg0[7:0]
        };
      if (_GEN_4 & _write_addr_match_T_1)
        slv_reg1 <= {
          S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg1[31:24],
          S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg1[23:16],
          S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg1[15:8],
          S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg1[7:0]
        };
      if (_GEN_4 & _write_addr_match_T_2)
        slv_reg2 <= {
          S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg2[31:24],
          S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg2[23:16],
          S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg2[15:8],
          S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg2[7:0]
        };
      if (_GEN_4 & _write_addr_match_T_3)
        slv_reg3 <= {
          S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg3[31:24],
          S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg3[23:16],
          S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg3[15:8],
          S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg3[7:0]
        };
    end
  end  // always @(posedge)
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY  = axi_wready;
  assign S_AXI_BRESP   = axi_bresp;
  assign S_AXI_BVALID  = axi_bvalid;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA   = axi_rdata;
  assign S_AXI_RRESP   = axi_rresp;
  assign S_AXI_RVALID  = axi_rvalid;
endmodule
