`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module axi_lite_slave_mmap_4x32_r4(
  input         clock,
                reset,
  input  [3:0]  S_AXI_AWADDR,
  input  [2:0]  S_AXI_AWPROT,
  input         S_AXI_AWVALID,
  output        S_AXI_AWREADY,
  input  [31:0] S_AXI_WDATA,
  input  [3:0]  S_AXI_WSTRB,
  input         S_AXI_WVALID,
  output        S_AXI_WREADY,
  output [1:0]  S_AXI_BRESP,
  output        S_AXI_BVALID,
  input         S_AXI_BREADY,
  input  [3:0]  S_AXI_ARADDR,
  input  [2:0]  S_AXI_ARPROT,
  input         S_AXI_ARVALID,
  output        S_AXI_ARREADY,
  output [31:0] S_AXI_RDATA,
  output [1:0]  S_AXI_RRESP,
  output        S_AXI_RVALID,
  input         S_AXI_RREADY
);

  reg        aw_en;
  reg        axi_awready;
  reg [3:0]  axi_awaddr;
  reg        axi_wready;
  reg        axi_bvalid;
  reg        axi_arready;
  reg [3:0]  axi_araddr;
  reg [31:0] axi_rdata;
  reg        axi_rvalid;
  reg [31:0] slv_reg0;
  reg [31:0] slv_reg1;
  reg [31:0] slv_reg2;
  reg [31:0] slv_reg3;
  always @(posedge clock) begin
    if (reset) begin
      aw_en <= 1'h1;
      axi_awready <= 1'h0;
      axi_awaddr <= 4'h0;
      axi_wready <= 1'h0;
      axi_bvalid <= 1'h0;
      axi_arready <= 1'h0;
      axi_araddr <= 4'h0;
      axi_rdata <= 32'h0;
      axi_rvalid <= 1'h0;
      slv_reg0 <= 32'h0;
      slv_reg1 <= 32'h0;
      slv_reg2 <= 32'h0;
      slv_reg3 <= 32'h0;
    end
    else begin
      automatic logic slv_reg_we =
        axi_wready & S_AXI_WVALID & axi_awready & S_AXI_AWVALID;
      automatic logic _slv_reg_re_T = axi_arready & S_AXI_ARVALID;
      automatic logic _GEN = ~axi_awready & S_AXI_AWVALID & S_AXI_WVALID & aw_en;
      automatic logic _GEN_0 = S_AXI_BREADY & axi_bvalid;
      automatic logic _GEN_1 = ~axi_arready & S_AXI_ARVALID;
      aw_en <= ~_GEN & (_GEN_0 | aw_en);
      axi_awready <= _GEN;
      if (_GEN)
        axi_awaddr <= S_AXI_AWADDR;
      axi_wready <= ~axi_wready & S_AXI_WVALID & S_AXI_AWVALID & aw_en;
      axi_bvalid <=
        axi_awready & S_AXI_AWVALID & ~axi_bvalid & axi_wready & S_AXI_WVALID | ~_GEN_0
        & axi_bvalid;
      axi_arready <= _GEN_1;
      if (_GEN_1)
        axi_araddr <= S_AXI_ARADDR;
      if (_slv_reg_re_T & ~axi_rvalid) begin
        automatic logic [3:0][31:0] _GEN_2 =
          {{slv_reg3}, {slv_reg2}, {slv_reg1}, {slv_reg0}};
        axi_rdata <= _GEN_2[axi_araddr[3:2]];
      end
      axi_rvalid <=
        _slv_reg_re_T & ~axi_rvalid | ~(axi_rvalid & S_AXI_RREADY) & axi_rvalid;
      if (slv_reg_we & axi_awaddr[3:2] == 2'h0)
        slv_reg0 <=
          {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg0[31:24],
           S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg0[23:16],
           S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg0[15:8],
           S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg0[7:0]};
      if (slv_reg_we & axi_awaddr[3:2] == 2'h1)
        slv_reg1 <=
          {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg1[31:24],
           S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg1[23:16],
           S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg1[15:8],
           S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg1[7:0]};
      if (slv_reg_we & axi_awaddr[3:2] == 2'h2)
        slv_reg2 <=
          {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg2[31:24],
           S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg2[23:16],
           S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg2[15:8],
           S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg2[7:0]};
      if (slv_reg_we & (&(axi_awaddr[3:2])))
        slv_reg3 <=
          {S_AXI_WSTRB[3] ? S_AXI_WDATA[31:24] : slv_reg3[31:24],
           S_AXI_WSTRB[2] ? S_AXI_WDATA[23:16] : slv_reg3[23:16],
           S_AXI_WSTRB[1] ? S_AXI_WDATA[15:8] : slv_reg3[15:8],
           S_AXI_WSTRB[0] ? S_AXI_WDATA[7:0] : slv_reg3[7:0]};
    end
  end // always @(posedge)
  assign S_AXI_AWREADY = axi_awready;
  assign S_AXI_WREADY = axi_wready;
  assign S_AXI_BRESP = 2'h0;
  assign S_AXI_BVALID = axi_bvalid;
  assign S_AXI_ARREADY = axi_arready;
  assign S_AXI_RDATA = axi_rdata;
  assign S_AXI_RRESP = 2'h0;
  assign S_AXI_RVALID = axi_rvalid;
endmodule

